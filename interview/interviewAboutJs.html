<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>js面试题 | ALin的个人博客</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy","copyFinish":"copied","expand":"expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ALin的个人博客" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>js面试题</h1></div><hr><div id="post-content"><h2 id="轮播图实现思路"><a href="#轮播图实现思路" class="headerlink" title="轮播图实现思路"></a>轮播图实现思路</h2><ol>
<li>首先开局一个div,叫做container，这个div包含整个轮播图区域的容器</li>
<li>里面再放一个div,取名carousel，走马灯。这个div与父元素宽高完全一致，完全充满</li>
<li>在这个区域里面放了一张张轮播图，也可以加上文字</li>
<li>使用弹性盒横向排列</li>
<li>溢出隐藏，translate</li>
<li>用绝对定位把指示器放到对应位置</li>
<li>布局完js交互代码</li>
</ol>
<h1 id="事件轮询机制"><a href="#事件轮询机制" class="headerlink" title="事件轮询机制"></a>事件轮询机制</h1><ul>
<li>js单线程但内核是多线程，异步操作由不同的浏览器内核模块调度执行</li>
<li>这也就引起了另一个问题，什么是异步？当事件触发时才会执行</li>
<li>主线程就是同步操作，同步任务在主线程上执行，形成一个执行栈，一旦执行栈中所有但同步任务执行完毕，系统就会读取任务队列（这个是事件轮询）</li>
<li>轮询任务队列就是异步任务，取某个任务队列就执行哪个，其实这句话就是把回调函数取出来，执行异步任务就是执行对应的回调函数，<br>任务队列，是异步任务运行结果<h2 id="宏任务微任务先后-执行顺序"><a href="#宏任务微任务先后-执行顺序" class="headerlink" title="宏任务微任务先后 执行顺序"></a>宏任务微任务先后 执行顺序</h2></li>
</ul>
<ul>
<li>宏任务：setInterval setTimeout ajax dom事件</li>
<li>微任务：promise async await </li>
<li>碰到setTimeout，分发到宏任务队列</li>
<li>碰到Promise.then，分发到微任务队列</li>
</ul>
<ul>
<li>在一次事件循环中，会先执行宏任务（主线程）再执行微任务（then）。都执行完后则进入下一次事件循环，再从宏任务开始执行（setTimeout）。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 直接执行</span><br><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 进入宏任务队列</span><br>    &#125;)<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">//直接执行</span><br>        <span class="hljs-title function_">resolve</span>()<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 进入微任务队列</span><br>&#125;   )<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 直接执行</span><br><span class="hljs-comment">// 结果为13542</span><br><span class="hljs-comment">// 所以在整段代码中，setTimeout是在then之后执行的，因为他俩不在同一次事件循环中。</span><br><span class="hljs-comment">// 所以，你问题的关键是在于你指的是一次事件循环中还是一整段代码中</span><br></code></pre></td></tr></table></figure></li>
<li>promise优先于 setTimeout 宏任务，所以setTimeout回调会最后执行，promise一旦被定义就会立即执行<br>promise的resolve和reject是异步执行的回调，所以resolve会被放到回调队列中，在主函数执行完和setTimeout之前调用await执行完毕后会让出线程</li>
</ul>
<ul>
<li>AIA</li>
</ul>
<ul>
<li>事件循环中，宏任务先执行</li>
<li>整段代码中，异步的微任务先执行<h2 id="由什么内核来处理？"><a href="#由什么内核来处理？" class="headerlink" title="由什么内核来处理？"></a>由什么内核来处理？</h2></li>
<li>async标记的函数会返回一个promise对象</li>
<li>onclick是由 浏览器内核 dom binding来处理 </li>
<li>settimeout 由浏览器内核 timer 模块来进行延时处理</li>
<li>ajax是由浏览器内核network模块来处理</li>
</ul>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. var变量提升</span><br>    <span class="hljs-keyword">var</span> a; <span class="hljs-comment">// 将变量a的声明提升至最顶端，赋值逻辑不提升。</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// undefined</span><br>    a = <span class="hljs-number">3</span>; <span class="hljs-comment">// 代码执行到原位置即执行原赋值逻辑</span><br><br><span class="hljs-comment">// 2. 函数变量提升</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo1); <span class="hljs-comment">// [Function: foo1]</span><br>    <span class="hljs-title function_">foo1</span>(); <span class="hljs-comment">// foo1</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo2); <span class="hljs-comment">// undefined</span><br>    <span class="hljs-title function_">foo2</span>(); <span class="hljs-comment">// TypeError: foo2 is not a function</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo1</span> () &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo1&quot;</span>);<br>    &#125;;<br>    <span class="hljs-keyword">var</span> foo2 = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;foo2&quot;</span>);<br>    &#125;;<br>    <span class="hljs-comment">// 即函数提升只会提升函数声明，而不会提升函数表达式。</span><br><br><span class="hljs-comment">// 3.</span><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>        a = <span class="hljs-number">10</span>;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//10</span><br>        <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;&#125;;<br>    &#125;<br>    <span class="hljs-title function_">foo</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//1</span><br>    <span class="hljs-comment">// 上述代码可以看成</span><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义一个全局变量 a</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 首先提升函数声明function a () &#123;&#125;到函数作用域顶端， 然后function a () &#123;&#125;等同于 var a =  function() &#123;&#125;;最终形式如下</span><br>        <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;; <span class="hljs-comment">// 定义局部变量 a 并赋值。</span><br>        a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 修改局部变量 a 的值，并不会影响全局变量 a</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 打印局部变量 a 的值：10</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-title function_">foo</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 打印全局变量 a 的值：1</span><br><br><span class="hljs-comment">// 4.函数提升与变量提升的优先级</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);    <span class="hljs-comment">// f a() &#123;console.log(10)&#125;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">a</span>());    <span class="hljs-comment">//  undefined</span><br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">//10</span><br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)   <span class="hljs-comment">//3</span><br>    a = <span class="hljs-number">6</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">a</span>());  <span class="hljs-comment">//a is not a function;</span><br>    <span class="hljs-comment">// 上述代码可以看成</span><br>    <span class="hljs-keyword">var</span> a = funtion () &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">10</span>)<br>    &#125;<br>    <span class="hljs-keyword">var</span> a;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);    <span class="hljs-comment">// f a() &#123;console.log(10)&#125;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">a</span>());  <span class="hljs-comment">//  undefined</span><br>    a = <span class="hljs-number">3</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)   <span class="hljs-comment">//3</span><br>    a = <span class="hljs-number">6</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">a</span>());   <span class="hljs-comment">//a() is not a function;</span><br>    <span class="hljs-comment">// 函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。</span><br><br><span class="hljs-comment">// 5.</span><br>    <span class="hljs-keyword">var</span> a =<span class="hljs-number">1</span> <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">x</span> ()&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// undefined 变量提升，没有赋值，若是没有下面两行，输出结果为1</span><br>        <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span> <br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// 2</span><br>        &#125;                        <br>    <span class="hljs-title function_">x</span>() <span class="hljs-comment">// 打印这个调用是undefined，因为没有return返回值</span><br></code></pre></td></tr></table></figure>


<h1 id="什么是重绘和重排？"><a href="#什么是重绘和重排？" class="headerlink" title="什么是重绘和重排？"></a>什么是重绘和重排？</h1><ul>
<li>重绘就是重新绘制（repaint）：是在一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</li>
<li>重排就是重新排列（reflow）：当渲染树的一部分必须更新并且节点的尺寸发生了变化，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。</li>
</ul>
<ol>
<li>引起重排的属性和方法</li>
</ol>
<ul>
<li><p>改变元素几何信息（大小和位置），都会引起，如：</p>
<p>  添加或删除可见的DOM元素</p>
<p>  元素位置改变，或者使用动画</p>
<p>  元素的尺寸改变（外边距、内边距、边框厚度、宽高等几何属性）</p>
<p>  内容改变（例如：文本改变或图片被另一个不同尺寸的图片替代、在input框输入内容）</p>
<p>  浏览器窗口尺寸改变（resize事件发生时）</p>
<p>  页面渲染初始化</p>
<p>  设置style属性的值</p>
<p>  计算offsetWidth、offsetHeight、offsetTop和offsetLeft等布局信息</p>
<p>  激活CSS伪类（如 :hover）</p>
<p>  查询某些属性或调用某些方法（如：getComputedStyle()、getBoundingClientRect()）</p>
</li>
</ul>
<ol start="2">
<li>几何属性和布局信息的属性有哪些？</li>
</ol>
<ul>
<li><p>几何属性包括布局、尺寸等可用数学几何衡量的属性：</p>
<p>  布局：display、float、position、list、table、flex、columns、grid<br>  尺寸：margin、padding、border、width、height<br>  获取布局信息的属性或方法：</p>
<pre><code>  offsetTop、offsetLeft、offsetWidth、offsetHeight

  scrollTop、scrollLeft、scrollWidth、scrollHeight

  clientTop、clientLeft、clientWidth、clientHeight

  getComputedStyle()

  getBoundingClientRect()
</code></pre>
</li>
</ul>
<ol start="3">
<li>引起重绘的属性：</li>
</ol>
<p>外观属性包括界面、文字等可用状态向量描述的属性，如：<br>    界面：appearance、outline、background、mask、box-shadow、box-reflect、filter、opacity、clip、border-radius、background-size、visibility</p>
<pre><code>文字：text、font、word
</code></pre>
<ol start="4">
<li>减少重排和重绘<br>避免一条一条的修改DOM的样式，可以直接修改DOM的className</li>
</ol>
<p>避免把DOM结点的属性值放在一个循环里当成循环里的变量</p>
<p>给动画的HTML元件使用fixed或absolute的position，那么修改他们的css是不会重排</p>
<p>避免在大量元素上使用:hover</p>
<p>分离读写操作</p>
<p>避免使用Table布局</p>
<p>避免设置多层内联样式</p>
<p>避免在布局信息改变时查询布局信息</p>
<p>当需要对DOM元素进行一系列的操作时，可以先使元素脱离文档流，再对其进行一些列操作，然后再把元素带回文档中</p>
<ol start="5">
<li>使元素脱离文档流的方法：<br>隐藏元素，施加修改，重新显示</li>
</ol>
<p>使用document fragment在当前DOM之外构建一个子树，再把它拷贝会文档</p>
<p>将元素元素拷贝到另一个脱离文档的节点中，修改副本，完成后再替换原始元素</p>
<h1 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h1><ul>
<li>面向对象：是将现实问题构建关系，然后抽象成类（class），给类定义属性和方法，再将类实例化成实例（instance），通过访问实例的属性和调用方法来进行使用。简写为：OOP</li>
<li>面向过程：是以一种以过程为中心的编程思想，这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。与面向对象明显的不同就是封装、继承、类。简写为POP<br>举例比喻：<br> 有一天你想吃鱼香肉丝了，怎么办呢？你有两个选择<br> 1、自己买材料，肉，鱼香肉丝调料，蒜苔，胡萝卜等等然后切菜切肉，开炒，盛到盘子里。<br> 2、去饭店，张开嘴：老板！来一份鱼香肉丝！<br>1就是面向过程，2就是面向对象</li>
<li>面向对象的优缺点？</li>
</ul>
<ol>
<li>首先你不需要知道鱼香肉丝是怎么做的，降低了耦合性。如果你突然不想吃鱼香肉丝了，想吃洛阳白菜，对于1你可能不太容易了，还需要重新买菜，买调料什么的。对于2，太容易了，大喊：老板！那个鱼香肉丝换成洛阳白菜吧，提高了可维护性。总的来说就是降低耦合，提高维护性！</li>
<li>优点：性能比面向对象好，因为类调用时需要实例化，开销比较大，比较消耗资源。<br>缺点：不易维护，不易复用，不易扩展</li>
</ol>
<ul>
<li>面向过程的优缺点？</li>
</ul>
<ol>
<li>面向过程是具体化，流程化的，解决一个问题，你需要一步一步分析，一步一步实现<br>面向对象是模型化的，你只需抽出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了</li>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 .<br>缺点：性能比面向过程差</li>
</ol>
<ul>
<li>面向对象三大特性</li>
</ul>
<ol>
<li>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提供复用和安全性</li>
<li>继承：提高代码复用性，继承是多态的前提</li>
<li>多态：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。  </li>
</ol>
<ul>
<li>面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们我们使用的就是面向对象</li>
</ul>
<h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><ol>
<li>Failed to load resource:the server responded with a status of :5500/favicon.ico:1 404(Not Found)     找不到网站API图标，就是网页标题前面那个小logo，比如百度</li>
<li>Target container is not a DOM element 少写了dom容器</li>
<li>Object are not valid as a React child 对象不能作为react一个合法的节点</li>
</ol>
<h1 id="严格模式，混杂模式"><a href="#严格模式，混杂模式" class="headerlink" title="严格模式，混杂模式"></a>严格模式，混杂模式</h1><h1 id="call，apply，bind"><a href="#call，apply，bind" class="headerlink" title="call，apply，bind"></a>call，apply，bind</h1><ol>
<li>共同点：功能一致，可以改变函数体内的this指向<br>语法：函数.call()  函数.apply()  函数.bind()</li>
<li>call 立即执行，有多个参数需要挨个写</li>
<li>apply 立即执行，第二个参数是数组</li>
</ol>
<ul>
<li>最大值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">32</span>,<span class="hljs-number">5</span>,<span class="hljs-number">425</span>,<span class="hljs-number">63256</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">1</span>,<span class="hljs-number">32</span>,<span class="hljs-number">5</span>,<span class="hljs-number">425</span>,<span class="hljs-number">63256</span>)) <span class="hljs-comment">// 63256</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(arr)) <span class="hljs-comment">// NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(arr)) <span class="hljs-comment">// null</span><br><span class="hljs-comment">// so</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>,arr)) <span class="hljs-comment">// 第二个参数</span><br></code></pre></td></tr></table></figure>

<ol start="4">
<li>bind 不会立即执行，返回一个新函数，若想立即执行需加（）<pre><code>有多个参数需要挨个写
</code></pre>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title function_">demo</span>() <span class="hljs-comment">// this指向window</span><br>demo.<span class="hljs-title function_">bind</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;) <span class="hljs-comment">// 这样做不会有任何改变，因为bind是返回一个新函数</span><br><span class="hljs-keyword">const</span> x = demo.<span class="hljs-title function_">bind</span>(&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;)<br><span class="hljs-title function_">x</span>() <span class="hljs-comment">// this变为&#123;a:1,b:2&#125;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;h1&quot;</span>&gt;</span>2222<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> text = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;h1&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// &lt;button id=&quot;btn&quot;&gt;1111&lt;/button&gt;</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>); <span class="hljs-comment">// btn,要想换成text，直接在后面bind </span></span><br><span class="language-javascript">    &#125;.<span class="hljs-title function_">bind</span>(text)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><ul>
<li>构造器中的this指向实例对象</li>
<li>全局定义函数this指向window</li>
</ul>
<h1 id="虚拟DOM和真实DOM区别"><a href="#虚拟DOM和真实DOM区别" class="headerlink" title="虚拟DOM和真实DOM区别"></a>虚拟DOM和真实DOM区别</h1><p>DOM意思是文档对象模型（Dcoument Object Model），它是一个结构化文本的抽象</p>
<ol>
<li>虚拟DOM不会进行排版与重绘操作</li>
<li>虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗</li>
<li>真实DOM频繁排版与重绘的效率是相当低的</li>
<li>虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部（同2）<br>使用虚拟DOM的损耗计算：<br>总损耗 = 虚拟DOM增删改 + （与Diff算法效率有关）真实DOM差异增删改 + （较少的节点）排版与重绘</li>
</ol>
<p>直接使用真实DOM的损耗计算：<br>总损耗 = 真实DOM完全增删改 + （可能较多的节点）排版与重绘</p>
<h1 id="检测数据类型"><a href="#检测数据类型" class="headerlink" title="检测数据类型"></a>检测数据类型</h1><pre><code>=============== typeof ===============
1) 检测数据类型的 校验基本数据类型没问题 但是引用类型有缺点
2) 缺点: 无法校验具体是哪一种类型的对象
</code></pre>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 【局限】: 无法判断具体是哪一种对象 </span><br><span class="hljs-comment">//  只要是引用类型 统一返回object</span><br><span class="hljs-comment">// typeof([]) =&gt; object</span><br><span class="hljs-comment">// typeof(&#123;&#125;) =&gt; object</span><br><span class="hljs-comment">// typeof(//) =&gt; object</span><br><span class="hljs-comment">// typeof(new Date()) =&gt; object</span><br></code></pre></td></tr></table></figure>
<pre><code>3) 作用:操作符返回一个字符串，表示未经计算的操作数的类型
</code></pre>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// null 是一个空指针对象 </span><br><span class="hljs-comment">// typeof(1) =&gt; number</span><br><span class="hljs-comment">// typeof(&#x27;1&#x27;) =&gt; string</span><br><span class="hljs-comment">// typeof(true) =&gt; boolean</span><br><span class="hljs-comment">// typeof(undefined) =&gt; undefined</span><br><span class="hljs-comment">// typeof(null) =&gt; object</span><br><span class="hljs-comment">// typeof(123456n) =&gt; bigint</span><br><span class="hljs-comment">// typeof(Symbol()) =&gt; symbol</span><br></code></pre></td></tr></table></figure>
<p>[Tip]两个及以上 typeof得到的结果都是字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">typeof</span> [<span class="hljs-number">12</span>,<span class="hljs-number">123</span>])<br>    <span class="hljs-comment">// =&gt; typeof typeof &quot;object&quot;</span><br>    <span class="hljs-comment">// =&gt; typeof &quot;string&quot;</span><br>    <span class="hljs-comment">// =&gt; string</span><br></code></pre></td></tr></table></figure>

<pre><code>============ instanceof ===============
</code></pre>
<p>运算符用于检测构造函数的prototype 属性是否出现在某个实例对象的原型链上<br>    例如：<br>        构造函数： function Animal(){}<br>        实例化： var ani = new Animal()<br>        校验：ani instanceof Animal =&gt; true<br>【局限性】：<br>    1. 原型链的指向可以任意修改 所以这种方式返回的结果不一定准确<br>    2. 无法检测基本数据类型 基本数据类型不是一个对象没有__proto__</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = []<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">__proto__</span>) <span class="hljs-title class_">Array</span>原型<br><br><span class="hljs-comment">// 修改原型指向</span><br>arr.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Data</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Data</span>) <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">__proto__</span>) <span class="hljs-title class_">Date</span>原型<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Data</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 基本数据类型</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>)<span class="hljs-comment">// false</span><br><span class="hljs-comment">// new Number(1) 将数据类型转为引用数据类型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>)<span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// Object.prototype.hasOwnProperty():方法会返回一个布尔值,指示对象自身属性中是否具有指定的属性(也就是,是否有指定的键)。</span><br> <span class="hljs-comment">// in:方法会返回一个布尔值,指示对象自身属性和原型链上的属性中是否具有指定的属性(也就是,是否有指定的键)</span><br> <span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zs&#x27;</span>&#125;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>)) <span class="hljs-comment">// true</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;age&#x27;</span>)) <span class="hljs-comment">// false</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span>)<br> <span class="hljs-comment">// 在原型上是存在toString方法 但是结果为false 这个方法不会检测公有属性</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;toString&#x27;</span>)<span class="hljs-comment">// false</span><br><span class="hljs-comment">// console.log(&#x27;name&#x27; in obj) // true</span><br><span class="hljs-comment">// console.log(&#x27;age&#x27; in obj) // false</span><br><span class="hljs-comment">// console.log(&#x27;toString&#x27; in obj) // true</span><br><br><span class="hljs-comment">// Object.getPrototypeOf() 方法返回指定对象的原型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getProrotypeOf</span>(obj))<br></code></pre></td></tr></table></figure>

<pre><code>================ constructor ===============  
【局限性】构造器指向也能改变
</code></pre>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zs&#x27;</span>&#125;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">__proto__</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Object</span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Array</span>) <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 改变构造器指向</span><br>obj.<span class="hljs-property">constructor</span> = <span class="hljs-literal">null</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Object</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>================ Object.prototype.toString.call() ================</p>
<ol>
<li>优点： 精准判断数据类型<br>缺点： 写法繁琐不容易记，推荐进行封装后使用</li>
<li>Object.prototype.toString()并不是用来转成字符串的,前面是对象 =&gt; 而是用来检测数据类型的 =&gt; [object Object]<br>(自动调用原型上的toString方法)</li>
<li>一般来说除{}之外的数据类型,字符串都是用””包起来,{}转字符串是调用</li>
<li></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// 字符串1,2,3</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">数组本身有toString方法,本身身上这个方法就是用来转字符串用的</span><br><span class="hljs-comment">原型身上也有一个toString方法,原型身上的方法是用来检测数据类型的,根据原型链原理先执行的是本身身上的toString方法,所以数组.toString()就是转成字符串</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<ol start="5">
<li>如果想用原型身上的toString()方法怎么办?<br>Object.prototype.toString.call(数组) 这句话检测数据类型的意思 =&gt; [object Array]<br>为什么要加call?<br>Object.prototype.toString()系统中有这个方法,数组会先执行自身,若想变成检测数据类型要先用系统中方法再指向原型链, call是this指向指向原型链</li>
</ol>
<h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="判断变量是不是数组，有哪些方法？"><a href="#判断变量是不是数组，有哪些方法？" class="headerlink" title="判断变量是不是数组，有哪些方法？"></a>判断变量是不是数组，有哪些方法？</h3><ol>
<li>isArray</li>
<li>instanceof(不严谨)</li>
<li>通过原型Object.prototype.toString.call</li>
<li>通过isPrototypeOf()</li>
<li>constructor</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;123&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(str)) <span class="hljs-comment">// false </span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(arr).<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;Array&#x27;</span>) != -<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(arr) ) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">constructor</span>.<span class="hljs-title function_">toString</span>(arr).<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;Array&#x27;</span>) &gt; -<span class="hljs-number">1</span> ) <span class="hljs-comment">// true &gt;-1 和!=-1是一个意思</span><br><br></code></pre></td></tr></table></figure>

<h2 id="如何判断一个对象是空对象"><a href="#如何判断一个对象是空对象" class="headerlink" title="如何判断一个对象是空对象"></a>如何判断一个对象是空对象</h2><ul>
<li>Object.keys().length 若&lt;0 就是空对象</li>
<li>json.stringify()</li>
</ul>
<h2 id="const对象的属性是否可以更改"><a href="#const对象的属性是否可以更改" class="headerlink" title="const对象的属性是否可以更改"></a>const对象的属性是否可以更改</h2><p>分基本数据类型和引用数据类型，在基本数据类型中作为一个常量，基本数据类型与地址无关<br>在引用数据类型中，引用数据类型在堆中，相当于给一个地址就可以找到我，只要内存地址不变，值怎样更改无所谓</p>
<h1 id="浅拷贝，深拷贝"><a href="#浅拷贝，深拷贝" class="headerlink" title="浅拷贝，深拷贝"></a>浅拷贝，深拷贝</h1><h1 id="字面量对象"><a href="#字面量对象" class="headerlink" title="字面量对象"></a>字面量对象</h1><p>js的字面量对象，就是一种简化的创建对象方式和用构造函数创建对象一样存在于堆内存当中</p>
<ul>
<li>语法:{属性:属性值,属性:属性值}<br>属性访问通过（.）语法访问:obj.propertyN ame<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1>满足三个特点</li>
</ul>
<ol>
<li>你定义的函数</li>
<li>你没调用</li>
<li>这函数最终执行 </li>
</ol>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="Object-is-与-，-区别"><a href="#Object-is-与-，-区别" class="headerlink" title="Object.is()与==，===区别"></a>Object.is()与==，===区别</h2><p>Object.is(+0,-0) false<br>Object.is(NaN,NaN) true<br>+0 === -0 true</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>8种<br>原始类型 ： null、undefined、number、string、boolean、symbol、bigint<br>引用类型 ： 对象</p>
<h2 id="属性存不存在"><a href="#属性存不存在" class="headerlink" title="属性存不存在"></a>属性存不存在</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 判断对象中是否存在某个属性</span><br><span class="hljs-comment">// @param &#123;Object&#125; obj 对象</span><br><span class="hljs-comment">// @param &#123;String&#125; key 属性名</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasProperty</span>(<span class="hljs-params">obj,key</span>) &#123;<br>    <span class="hljs-keyword">return</span> key <span class="hljs-keyword">in</span> obj<br>&#125;<br><br><span class="hljs-comment">/*1. 不能用undefined去判断</span><br><span class="hljs-comment">向下面这行代码*/</span><br><span class="hljs-comment">// function hasProperty(obj,key) &#123;</span><br><span class="hljs-comment">//     return obj[key] !== undefined</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">/* 因为 */</span><br>    <span class="hljs-comment">// var obj = &#123;a:undefined&#125;</span><br>    <span class="hljs-comment">// console.log(hasProperty(obj,&#x27;a&#x27;)) // 按理论来说obj中有a，但输出结果为false</span><br><br><span class="hljs-comment">/* 2.这样也不可以 */</span><br>    <span class="hljs-comment">// var obj = &#123;a:undefined,b:1&#125;</span><br>    <span class="hljs-comment">// function hasProperty(obj,key) &#123;</span><br>    <span class="hljs-comment">//     return Object.keys(obj).includes(key) // 用数组的include方法判断数组里面存不存在这个参数的值</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj))<span class="hljs-comment">// 这样可以获取到对象里面全部属性</span><br><span class="hljs-comment">/* 但如果是对象，比如在加一个c */</span><br>    <span class="hljs-comment">// Object.defineProperty(obj,&#x27;c&#x27; &#123;</span><br>    <span class="hljs-comment">//     enumerable:false,</span><br>    <span class="hljs-comment">//     value:1</span><br>    <span class="hljs-comment">// &#125;)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">c</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)) <span class="hljs-comment">// 还是只有[&#x27;a&#x27;,&#x27;b&#x27;] false 没有c</span><br></code></pre></td></tr></table></figure>

<h2 id="DOM和BOM的区别"><a href="#DOM和BOM的区别" class="headerlink" title="DOM和BOM的区别"></a>DOM和BOM的区别</h2><ol>
<li>DOM是文档对象模型，是W3C组织推荐可扩展标记语言（html或者xhtml）的标准编程接口</li>
</ol>
<ul>
<li>DOM树又称为文档树模型，把文档映射成树形结构，通过节点对象对其处理，处理的结果可以加入到当前的页面。<ul>
<li>文档：一个页面就是一个文档，DOM中使用document表示</li>
<li>节点：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用node表示</li>
<li>标签节点：网页中的所有标签，通常称为元素节点，又简称为“元素”，使用element表示</li>
</ul>
</li>
</ul>
<ol start="2">
<li>BOM浏览器对象模型，提供了独立于内容而与浏览器窗口进行交互对象，其核心对象是window</li>
</ol>
<ul>
<li>BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</li>
<li>​BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。</li>
<li>BOM的构成<br>BOM 比 DOM 更大，它包含 DOM。</li>
</ul>
<ol start="3">
<li>二者区别<br class='item-img' data-src='/public/DOM.png'><img src="/public/DOM.png" alt="alt"></li>
</ol>
<h2 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;10000000000&#x27;</span> <span class="hljs-comment">//把这个字符串变成10,000,000,000</span><br><span class="hljs-title class_">Number</span>(str).<span class="hljs-title function_">toLocalString</span>()<br>str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(?=\B(\d&#123;3&#125;)+$)/g</span>,<span class="hljs-string">&#x27;,&#x27;</span>)<br><br><span class="hljs-string">&quot;1234567890&quot;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\B(?=(?:\d&#123;3&#125;)+(?!\d))/g</span>,<span class="hljs-string">&quot;,&quot;</span>) <br></code></pre></td></tr></table></figure>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>前瞻<br>exp1(?=exp2) 查找exp2前面的exp1<br>后顾<br>(?&gt;=exp2)exp1 查找exp2后面的exp1<br>负前瞻<br>exp1(?!exp2) 查找后面不是exp2的exp1<br>负后顾<br>(?&lt;!exp2)exp1 查找前面不是exp2点exp1<br>\d代表的意思是匹配数字<br>+：匹配前面子表达式1次以上<br>\b 表示单词边界<br>\B 表示非单词边界，应理解为（非单词）边界，而不是非（单词边界），它仍然匹配的是边界</p>
<ul>
<li>边界<br>我将正则中的位置分为 字符的占位 和 字符的间隙。<br>字符的占位是显式的位置。<br class='item-img' data-src='/public/regb.png'><img src="/public/regb.png" alt="alt"><br class='item-img' data-src='/public/B.png'><img src="/public/B.png" alt="alt"></li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ol>
<li>原型链解决了什么问题？<br>js万物皆对象的逻辑<br>解决创新对象过程中浪费内存的问题<br>底层方法的继承<br>减少内存占用空间<br>比如new一个对象，是用构造函数给这个对象实例，当你要复用这个对象，构造函数的方法也要复用，每次用的时候都会创建新方法，当你给这个对象方法改成原型，每次调用，这个函数方法就不会去每次都创建一个新的</li>
<li>在作用域中变量标识的搜索是按什么规则来的？对象的属性获取是基于什么规则的？<br>任何函数都有一个prototype，称为函数的原型，其实就是一个对象可以当成构造函数来使用，通过new关键字去创建这个函数的实例，创建万会自动为这个实例加一个属性就是__proto__，这个属性叫隐式原型其实就是那个构造函数的原型。<br>任何一个对象都有这个关系<br>函数实际上是new了一个function来定义，只不过平时没这么写，实际上内部函数都是new Function，二创建了一个对象</li>
</ol>
<h2 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h2><p>有点类似工厂模式，是一个静态方法，可以把对象转换为所需要的类型。<br>例子：Integer.valueOf(“1005”),其实等价于new Integer(“1005”)<br>valueof可以转换字符串，double，short等类型</p>
<ul>
<li>优势：不需要显式的建立对象<br class='item-img' data-src='/public/valueOf.png'><img src="/public/valueOf.png" alt="alt"></li>
</ul>
<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>相当于undefined，把undefined当作变量去判断<br>运算原理：执行表达式，不返回任何结果。<br>常用于将一个链接变成死链。</p>
<p>例：将一个链接变为死链<br>实现如下要求：</p>
<ol>
<li>保留住超链接的样式</li>
<li>用户点击该超链接的时候执行一段JS代码</li>
<li>页面不能跳转</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 第一步 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    顶页<br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>[--------链接--------]<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- &quot;&quot; 返回的是一个空字符串，href会按当前路径跳转 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 第二步 --&gt;</span><br><span class="hljs-comment">&lt;!-- 将底部链接标签中添加一个click事件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Hello World&#x27;)&quot;</span>&gt;</span>[--------链接--------]<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 第三步 --&gt;</span><br><span class="hljs-comment">&lt;!-- 在href里添加javascript:void(0) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:void(0)&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;Hello World&#x27;)&quot;</span>&gt;</span>[--------链接--------]<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>其中javascript的作用是：告诉浏览器后面跟的是一段JS代码。<br>下面程序中javascript是不可省略的，如果不加，void(0)就会被浏览器认为是一个相对路径。<br>void(表达式)的作用是执行括号里的表达式，但不返回任何结果。(表达式可以填写任意数字，不影响。)<br>如果href后面的双引号里什么都不填，还是会返回一个空字符串。就好比在一个函数里返回&quot;&quot;<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">doSome</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-javascript">	&#125;</span><br><span class="language-javascript">	<span class="hljs-title function_">alert</span>(<span class="hljs-title function_">doSome</span>());</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>而void(0)连空字符串都不会返回。<br><br>使用void(0)后，就没有路径可以跳转了，所以页面不会跳转。<br></code></pre></td></tr></table></figure>

<h2 id="首屏加载慢怎么解决"><a href="#首屏加载慢怎么解决" class="headerlink" title="首屏加载慢怎么解决"></a>首屏加载慢怎么解决</h2><ol>
<li>减小入口文件体积</li>
<li>静态资源本地缓存</li>
<li>UI框架按需引入</li>
<li>图片资源压缩</li>
<li>组件重复打包</li>
<li>开启SSR</li>
<li>去除loading</li>
</ol>
<h2 id="如何正确取消事件默认行为"><a href="#如何正确取消事件默认行为" class="headerlink" title="如何正确取消事件默认行为"></a>如何正确取消事件默认行为</h2><p>比如：视频播放后面的滚轮事件不可动</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;wheel&#x27;</span>,wheelHandler,&#123;<br>        <span class="hljs-attr">passive</span>:<span class="hljs-literal">false</span> <span class="hljs-comment">// 如果不加这第三个属性，会报错</span><br>    &#125;)<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">wheelHandler</span>(<span class="hljs-params">e</span>) &#123;<br>        e.<span class="hljs-title function_">preventDefault</span>()<br>    &#125; <br>    mouseModal.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        video.<span class="hljs-title function_">pause</span>() <span class="hljs-comment">// 视频停止</span><br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;wheel&#x27;</span>,wheelHandler)<br>    &#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    除此之外现在常用方法：给最外面盒子设置固定宽高，溢出隐藏</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h2 id="console命令详解"><a href="#console命令详解" class="headerlink" title="console命令详解"></a>console命令详解</h2><p>除了log函数还有很多</p>
<ol>
<li>console.debug:打印调试信息的<br>浏览器在默认情况下是隐藏调试信息的，可以在检查——console中把Default levels变成Verbose，可以看到调试信息<br>Verbose显示的消息一般级别很低，比如页面有一个循环，卡的时间较长，就会显示到这里与log差不多</li>
<li>console.info:与log差不多，在谷歌浏览器无甚区别，但在别的浏览器比如Safari，它前面会有一个！</li>
<li>打印表格<br>console.table([<br> {first:’aaa’,last:’bbb’},<br> {first:’ccc’,last:’dddd’,birthday:899902}<br>])<br>这样打印直接就是一个表格，方便观察这个对象数组</li>
<li>打印分组<br>消息比较多，比如计时器打印很多消息，可以把同类型的消息分成一个组<br>const label = ‘Package’</li>
</ol>
<ul>
<li>首先给这个组起个名字 : console.group(label) 这个是默认要展开的情况<br>若默认折叠：console.groupCollapsed(label)<br>console.log(‘hhh’)<br>console.log(‘aaa’)</li>
<li>最后结束这个组 console.groupEnd(label)<br>打印出来结果<pre><code>  先有个下拉箭头 Package
                  hhh
                  aaa
</code></pre>
</li>
</ul>
<ol start="5">
<li>打印对象结构<br>console.dir(document.body) // body下拉箭头，展现对象结构<br>console.log(document.body) //<body>…</body></li>
<li>打印计时<br>比如比较几段代码消耗的时间<br>console.time(‘loop’)<br>一些耗时的操作<br>const start = Date.now()<br>while(Date.now() - start &lt; 2000) {}<br>console.timeEnd(‘loop’)</li>
<li>打印计数<br>const start = Date.now()<br>while(Date.now() - start &lt; 20) {<br> const.count(‘loop’)<br>}<br>console.countReset(‘loop’)</li>
<li>打印堆栈信息<br>比如需要知道函数在被谁调用<br>function b() {<br> console.trace()<br>}<br>function a() {<br> b()<br>}<br>a()<br>输出结果： console.trace<pre><code>     b 打印位置在b函数
     a a调用b
</code></pre>
</li>
<li>断言<br>做一些简单测试<br>function sum(a,b) {<br> return a+b<br>}<br>console.assert(sum(1,2) === 3) //若正确，测试通过则表现为没有任何显示，若测试结构为假，打印错误</li>
<li>打印警告<br>写框架写库用的比较多<br>console.warn(‘Abandon Hope All Ye Who Enter’)</li>
<li>打印错误<br>console.error(‘You has made a huge mistake’)</li>
<li>清空消息<br>console.log(1)<br>console.clear()<br>console.log(2) //只会看到2，因为1被清空了</li>
<li>给消息添加样式<br>const styles = <code>padding:5px;color:white;background:#999;font-style:italic</code>;<br>console.log(‘%cVariety hhh’,styles)<br>这样就给Variety hhh这句话也添加上这个样式了</li>
</ol>
<h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p>简写：function *<br>什么是生成器函数？</p>
<ul>
<li><p>这个函数返回一个可枚举的对象（官方说法返回Generator对象）</p>
</li>
<li><p>Generator 函数是 ES6 提供的一种异步编程解决方案。</p>
</li>
<li><p>Generator函数像一个状态机，保存了许多状态，并将这些状态作为遍历器对象返回。</p>
</li>
<li><p>可以通过.next()枚举其中的数据。内部通过yield关键字实现步进。<br>语法：function* name([param[, param[, … param]]]) { statements }</p>
</li>
<li><p>name 函数名</p>
</li>
<li><p>param 要传递给函数的一个参数的名称，一个函数最多可以有 255 个参数。</p>
</li>
<li><p>statements 普通 JS 语句。<br>生成器函数在执行时能暂停，后面又能从暂停处继续执行</p>
</li>
<li><p>调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 迭代器 （ iterator ）对象。当这个迭代器的 next() 方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现yield的位置为止，yield 后紧跟迭代器要返回的值。或者如果用的是 yield*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。</p>
</li>
<li><p>next()方法返回一个对象，这个对象包含两个属性：value 和 done，value 属性表示本次 yield 表达式的返回值，done 属性为布尔类型，表示生成器后续是否还有 yield 语句，即生成器函数是否已经执行完毕并返回</p>
</li>
<li><p>调用 next()方法时，如果传入了参数，那么这个参数会传给上一条执行的 yield 语句左边的变量，例如下面例子中的x</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">10</span>;<br>    x=<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br>    <span class="hljs-keyword">yield</span> x;<br>&#125;<br><br><span class="hljs-keyword">var</span> gen_obj=<span class="hljs-title function_">gen</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen_obj.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// 执行 yield 10，返回 10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen_obj.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// 执行 yield &#x27;foo&#x27;，返回 &#x27;foo&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen_obj.<span class="hljs-title function_">next</span>(<span class="hljs-number">100</span>));<span class="hljs-comment">// 将 100 赋给上一条 yield &#x27;foo&#x27; 的左值，即执行 x=100，返回 100</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen_obj.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// 执行完毕，value 为 undefined，done 为 true</span><br></code></pre></td></tr></table></figure>

<p>当在生成器函数中显式 return 时，会导致生成器立即变为完成状态，即调用 next() 方法返回的对象的 done 为 true。如果 return 后面跟了一个值，那么这个值会作为当前调用 next() 方法返回的 value 值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 普通示例 */</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">idMaker</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(index&lt;<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">yield</span> index++;<br>&#125;<br><br><span class="hljs-keyword">var</span> gen = <span class="hljs-title function_">idMaker</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">/* 生成器可以接收参数 */</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">idMaker</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> index = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] || <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        <span class="hljs-keyword">yield</span> index++;<br>&#125;<br><br><span class="hljs-keyword">var</span> gen = <span class="hljs-title function_">idMaker</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 6</span><br><br><span class="hljs-comment">/* yield*示例 */</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">anotherGenerator</span>(<span class="hljs-params">i</span>) &#123;<br>  <span class="hljs-keyword">yield</span> i + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">yield</span> i + <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">yield</span> i + <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generator</span>(<span class="hljs-params">i</span>)&#123;<br>  <span class="hljs-keyword">yield</span> i;<br>  <span class="hljs-keyword">yield</span>* <span class="hljs-title function_">anotherGenerator</span>(i);<span class="hljs-comment">// 移交执行权</span><br>  <span class="hljs-keyword">yield</span> i + <span class="hljs-number">10</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> gen = <span class="hljs-title function_">generator</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 11</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 12</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 13</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>); <span class="hljs-comment">// 20</span><br><br><span class="hljs-comment">/* 传递参数 */</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">createIterator</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> first = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> second = <span class="hljs-keyword">yield</span> first + <span class="hljs-number">2</span>; <span class="hljs-comment">// 4 + 2</span><br>                                  <span class="hljs-comment">// first =4 是 next(4) 将参数赋给上一条的</span><br>    <span class="hljs-keyword">yield</span> second + <span class="hljs-number">3</span>;             <span class="hljs-comment">// 5 + 3</span><br>&#125;<br><br><span class="hljs-keyword">let</span> iterator = <span class="hljs-title function_">createIterator</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());    <span class="hljs-comment">// &quot;&#123; value: 1, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">4</span>));   <span class="hljs-comment">// &quot;&#123; value: 6, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>(<span class="hljs-number">5</span>));   <span class="hljs-comment">// &quot;&#123; value: 8, done: false &#125;&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());    <span class="hljs-comment">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">yieldAndReturn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;Y&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R&quot;</span>;<span class="hljs-comment">//显式返回处，可以观察到 done 也立即变为了 true</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;unreachable&quot;</span>;<span class="hljs-comment">// 不会被执行了</span><br>&#125;<br><br><span class="hljs-comment">/* 显示返回 */</span><br><span class="hljs-keyword">var</span> gen = <span class="hljs-title function_">yieldAndReturn</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: &quot;Y&quot;, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: &quot;R&quot;, done: true &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen.<span class="hljs-title function_">next</span>()); <span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br><br><span class="hljs-comment">/* 生成器不能被当构造器具使用 */</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> f; <span class="hljs-comment">// throws &quot;TypeError: f is not a constructor&quot;</span><br><br><span class="hljs-comment">/* 使用迭代器遍历二维数组并转换成一堆数组 */</span><br><br><span class="hljs-comment">// 二维数组：类型 数组名[行号][列号]</span><br><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">iterArr</span>(<span class="hljs-params">arr</span>) &#123;            <span class="hljs-comment">//迭代器返回一个迭代器对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)) &#123;         <span class="hljs-comment">// 内节点</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>          <span class="hljs-keyword">yield</span>* <span class="hljs-title function_">iterArr</span>(arr[i]);   <span class="hljs-comment">// (*) 递归</span><br>      &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;                          <span class="hljs-comment">// 离开</span><br>      <span class="hljs-keyword">yield</span> arr;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 使用 for-of 遍历：</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> x <span class="hljs-keyword">of</span> <span class="hljs-title function_">iterArr</span>(arr)) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);               <span class="hljs-comment">// a  b  c  d  e</span><br>&#125;<br><span class="hljs-comment">// 或者直接将迭代器展开：</span><br><span class="hljs-keyword">var</span> arr = [ <span class="hljs-string">&#x27;a&#x27;</span>, [<span class="hljs-string">&#x27;b&#x27;</span>,[ <span class="hljs-string">&#x27;c&#x27;</span>, [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]]]];<br><span class="hljs-keyword">var</span> gen = <span class="hljs-title function_">iterArr</span>(arr);<br>arr = [...gen];                        <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><br></code></pre></td></tr></table></figure>

<h3 id="generator函数与构造函数的区别"><a href="#generator函数与构造函数的区别" class="headerlink" title="generator函数与构造函数的区别"></a>generator函数与构造函数的区别</h3><ol>
<li>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法</li>
<li>Generator 函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象，所以Generator 函数也不能跟new命令一起用。</li>
</ol>
<h3 id="BTW—-CSP"><a href="#BTW—-CSP" class="headerlink" title="BTW— CSP"></a>BTW— CSP</h3><p>Content Security Policy内容安全策略，可能会阻止一些脚本或者样式的执行</p>
<h2 id="let-const-var"><a href="#let-const-var" class="headerlink" title="let const var"></a>let const var</h2><p>let定义变量<br>const定义常量<br>有检测工具eslint用var会报错</p>
<h2 id="一个监听元素重叠"><a href="#一个监听元素重叠" class="headerlink" title="一个监听元素重叠"></a>一个监听元素重叠</h2><p>有一个列表，放着排列好的图片，滚动下拉加载事件，希望只有滚动到底部才出现加载小圆圈，调用加载函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*我们可以不去监控这个滚动条，而是监控加载小圆圈，监控它什么时候出现在我们看到的画面中 */</span><br>    <span class="hljs-comment">/* H5的API提供了一个构造函数：监控某一个元素，随着滚动条的滚动有没有出现在另一个元素的可见范围内 */</span><br>    <span class="hljs-comment">/*因此我们先建立一个观察者 */</span><br>        <span class="hljs-keyword">var</span> ob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">entries</span>)&#123;<br>            <span class="hljs-keyword">var</span> entry = entries[<span class="hljs-number">0</span>]<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entry)<br>            <span class="hljs-comment">// 打印后发现里面有两个属性，判断离开和进入isIntersecting:false是离开，true是进入</span><br>            <span class="hljs-keyword">if</span>(entry.<span class="hljs-property">isIntersecting</span> &amp;&amp; !isLoading) &#123; <span class="hljs-comment">// 表示说目前超过10%了有重叠，同事又没有正在去拿列表，这个时候才加载更多</span><br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;加载更多&#x27;</span>)<br>                <span class="hljs-title function_">more</span>() <span class="hljs-comment">//调用这个下拉加载获取对应数据的函数</span><br>            &#125;<br>        &#125;,&#123;<br>            <span class="hljs-comment">// 表示说你到时候观察的元素，观察它与哪个元素重叠</span><br>            <span class="hljs-attr">root</span>:<span class="hljs-literal">null</span> <span class="hljs-comment">// 如果写null或者不写，表示默认观察的是整个浏览器的可视窗口，就是视口。这里就是要观察与视口重叠</span><br>            <span class="hljs-attr">thresholds</span>:<span class="hljs-number">0.1</span><br>        &#125;)<br>        <span class="hljs-comment">// 观察</span><br>        ob.<span class="hljs-title function_">observe</span>(loading) <br>        <span class="hljs-comment">// ob.observe(loading) 这个是用来证明一个观察者可以观察无限个元素</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1.观察这个元素与哪个元素有没有重叠？</span><br><span class="hljs-comment">            IntersectionObserver，第二个参数，实际上是一个配置对象</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">        2. 重叠多少？</span><br><span class="hljs-comment">            0-1之间的取值，0是完全没有重叠，1就是完全重叠，0.5重叠一半</span><br><span class="hljs-comment">            thresholds门槛 thresholds:0~1</span><br><span class="hljs-comment">        3. 重叠要做什么？</span><br><span class="hljs-comment">            IntersectionObserver 需要它的第一个参数，是一个函数</span><br><span class="hljs-comment">            在这个例子中，当与视口接触到10%就会触发这个函数，把重叠的元素传入entries这个数组中去</span><br><span class="hljs-comment">        */</span> <br></code></pre></td></tr></table></figure>

<h3 id="BTW—React"><a href="#BTW—React" class="headerlink" title="BTW—React"></a>BTW—React</h3><p>可以用ahooks里的useDocumentVisibility</p>
<h2 id="后台页面计时器失活怎么解决"><a href="#后台页面计时器失活怎么解决" class="headerlink" title="后台页面计时器失活怎么解决"></a>后台页面计时器失活怎么解决</h2><p>比如后端写了setInterval(),每隔一段时间创建一个小熊的位置</p>
<ul>
<li>造成原因：当切换别的浏览器页面时候，浏览器会认为你之前的标签页都已经隐藏了，为了提升效率减少电量消耗不会频繁的去执行计时器，会把setInterval时间间隔调成最少1秒钟，所以里面设置所有小于1秒钟的都会被重置为一秒钟</li>
<li>解决方案：</li>
</ul>
<ol>
<li>切换到别的页面，把这个游戏暂停<br>game.stop()<br>game.start()<br>之后监听这个页面有没有被隐藏</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;visibilitychange&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// visibilitychange 表示当我们的页面可见性发生变化会触发这个事件</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(visibilityState) <span class="hljs-comment">//查看一下可见度</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">&#x27;hidden&#x27;</span>) &#123;<br>        g.<span class="hljs-title function_">stop</span>()<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        g.<span class="hljs-title function_">start</span>()<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="three-js如何处理"><a href="#three-js如何处理" class="headerlink" title="three.js如何处理"></a>three.js如何处理</h3><p>用requestframe<br>requestAnimationFrame代替定时器<br>页面切换了页面停止渲染，这个函数也会停<br>只是切换回来的时候会加速执行中间的时间，如果是多个动画拼接就会出现问题</p>
<h3 id="除此之外可以试试webworker来解决"><a href="#除此之外可以试试webworker来解决" class="headerlink" title="除此之外可以试试webworker来解决"></a>除此之外可以试试webworker来解决</h3><p>用new Woker()来专门跑这个定时器</p>
<h2 id="手写promise-all"><a href="#手写promise-all" class="headerlink" title="手写promise.all"></a>手写promise.all</h2><p>Promise.all 可以将多个Promise实例包装成一个新的Promise实例<br>同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被 reject 失败状态的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">proms</span>) &#123;<br>      <span class="hljs-keyword">let</span> res,rej;<br>      <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>          res = resolve;<br>          rej = reject<br>      &#125;);<br>      <span class="hljs-comment">// 设置p的状态</span><br><span class="hljs-keyword">const</span> result = []; <br>      <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><span class="hljs-comment">// 数量</span><br>      <span class="hljs-keyword">let</span> fulFilledCount = <span class="hljs-number">0</span> <span class="hljs-comment">//完成的数量</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proms)<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> prom <span class="hljs-keyword">of</span> proms) &#123;		<br>          <span class="hljs-keyword">const</span> i = count<br>          count++;<br>          <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(prom).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>              <span class="hljs-comment">// 将成功的数据汇总到result</span><br>              result[i] = data<br>              <span class="hljs-comment">// 判断是不是全部完成,结束这个循环</span><br>              fulFilledCount++<br>              <span class="hljs-keyword">if</span>(fulFilledCount === count) &#123;<br>                  <span class="hljs-title function_">res</span>(result)<br>              &#125;			<br>          &#125;,rej)	<br>      &#125;		<br>      <span class="hljs-keyword">if</span>(count === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-title function_">res</span>(result)<br>      &#125;<br>      <span class="hljs-keyword">return</span> p<br>  &#125;<br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">datas</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(datas)<br>  &#125;)<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">      迭代器英文：iterator</span><br><span class="hljs-comment">      可迭代对象：iterable</span><br><span class="hljs-comment">      迭代器是一个对象，帮助我们遍历某种数据结构，这个对象必须包含next方法，next必须返回包含done和value属性的对象</span><br><span class="hljs-comment">      可迭代对象：</span><br><span class="hljs-comment">  */</span><br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">myAll</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> res,rej,<br>    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>        res = resolve<br>        rej = reject<br>    &#125;)<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> fulfilled = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> prom <span class="hljs-keyword">of</span> proms) &#123;<br>        <span class="hljs-keyword">const</span> i = count<br>        count++<br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(prom).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>            result[i] = data<br>            fulfilled++<br>            <span class="hljs-keyword">if</span>(fulfilled === count)&#123;<br>                <span class="hljs-title function_">res</span>(result)<br>            &#125;<br>        &#125;,rej)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(count === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-title function_">res</span>(result)<br>    &#125;<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">datas</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(datas)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="和-区别"><a href="#和-区别" class="headerlink" title="==和===区别"></a>==和===区别</h2><p>=== 数据类型<br>== 值的判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>) == <span class="hljs-title class_">String</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br><span class="hljs-title class_">Number</span>(<span class="hljs-number">1</span>) === <span class="hljs-title class_">String</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure>

<h2 id="js的异步基础是什么"><a href="#js的异步基础是什么" class="headerlink" title="js的异步基础是什么"></a>js的异步基础是什么</h2><p>回调函数</p>
<h2 id="写一个函数判断版本号的大小"><a href="#写一个函数判断版本号的大小" class="headerlink" title="写一个函数判断版本号的大小"></a>写一个函数判断版本号的大小</h2><p>语义版本规范<br>split，正则都可以<br>但更好的方法，生成器函数</p>
<p>例：<br>12.3.1<br>12.7.8<br>1.5.6-alpha.1<br>7.2.3-beta</p>
<p>var str = ‘12.3.1’<br>let result = ‘’<br>for(var i=0;i&lt;str.length;i++) {<br>    if(str[i] == ‘.’) {<br>        console.log(str[i])<br>        break<br>    }else{<br>        result+=str[i]</p>
<pre><code>&#125;
console.log(result)
</code></pre>
<p>}</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-keyword">function</span>* <span class="hljs-title function_">walk</span>(<span class="hljs-params">str</span>) &#123;<br>        <span class="hljs-keyword">let</span> part = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-comment">// 定义一个终结符/分界符</span><br>        <span class="hljs-keyword">let</span> terminals = [<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;-&#x27;</span>] <span class="hljs-comment">// 若严格按照语义版规范还有一个+</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span>; i&lt;str.<span class="hljs-property">length</span> ; i++) &#123;<br>            <span class="hljs-comment">// 每拿到一个字符串判断当前这个字符是不是终结符 </span><br>            <span class="hljs-keyword">if</span>(terminals.<span class="hljs-title function_">includes</span>(str[i])) &#123;<br>                <span class="hljs-comment">// 遍历到终结符，就可以把之前追加到字符串中的字符成为迭代器的下一项了</span><br>                <span class="hljs-keyword">yield</span> part;<br>                part = <span class="hljs-string">&#x27;&#x27;</span> <br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                part+=str[i]<br>            &#125;<br>            <span class="hljs-comment">// 若要是没有遇到任何终结符</span><br>            <span class="hljs-keyword">if</span>(part) &#123;<br>                <span class="hljs-keyword">yield</span> part;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 调用这个函数</span><br><span class="hljs-keyword">const</span> iterator = <span class="hljs-title function_">walk</span>(<span class="hljs-number">1.5</span><span class="hljs-number">.6</span>-alpha<span class="hljs-number">.1</span>)<br><span class="hljs-keyword">let</span> n = iterator.<span class="hljs-title function_">next</span>()<span class="hljs-comment">// &#123;value:1,done:false&#125;</span><br>conosle.<span class="hljs-title function_">log</span>(n) <span class="hljs-comment">// &#123;value:1,done:false&#125;</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> iterator) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="JS继承的几种方式"><a href="#JS继承的几种方式" class="headerlink" title="JS继承的几种方式"></a>JS继承的几种方式</h2><ol>
<li>构造函数继承 </li>
<li>原型链继承 </li>
<li>组合继承 </li>
<li>class继承 </li>
<li>实例继承 </li>
<li>拷贝继承 </li>
<li>寄生组合继承</li>
</ol>
<ul>
<li>构造函数继承<br>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> =<span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br>  <span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat.<span class="hljs-title function_">sleep</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Animal</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Cat</span>); <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure>
<p>可以发现，当我们在原型链上添加属性和方法时，子级并没有继承父级的属性和方法总结如下：<br>特点：<br>解决了子类实例共享父类引用属性的问题<br>创建子类实例时，可以向父类传递参数<br>可以实现多继承（call多个父类对象）<br>缺点：<br>实例并不是父类的实例，只是子类的实例<br>只能继承父类在构造函数里声明的属性和方法，不能继承父级原型链上的属性和方法<br>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</p>
<ul>
<li>原型链继承</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">body</span> = [<span class="hljs-string">&#x27;head&#x27;</span>,<span class="hljs-string">&#x27;arm&#x27;</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i can eat&#x27;</span>)<br>&#125;<br><span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat ,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Animal</span>); <span class="hljs-comment">//true </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Cat</span>); <span class="hljs-comment">//true</span><br><span class="hljs-keyword">var</span> cat1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><span class="hljs-keyword">var</span> cat2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>cat1.<span class="hljs-property">body</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;foot&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat1,cat2);<br></code></pre></td></tr></table></figure>

<p>特点：</p>
<p>非常纯粹的继承关系，实例是子类的实例，也是父类的实例<br>父类新增原型方法/原型属性，子类都能访问到<br>简单，易于实现<br>缺点：<br>可以在Cat构造函数中，为Cat实例增加实例属性。但要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行<br>无法实现多继承<br>来自原型对象的所有属性被所有实例共享<br>创建子类实例时，无法向父类构造函数传参</p>
<ul>
<li>组合继承<br>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  instance.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;i can eat&#x27;</span>);<br>&#125;<br><span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">//组合继承也是需要修复构造函数指向的</span><br><span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Cat</span>;<br><span class="hljs-keyword">var</span> cat1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><span class="hljs-keyword">var</span> cat2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>cat1.<span class="hljs-property">body</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;foot&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat1,cat2)<br><br></code></pre></td></tr></table></figure>
<p>组合方式排除了构造函数继承和原型链继承的弊端，是JS中最常用的继承模式了 总结：<br>特点：</p>
<p>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法<br>既是子类的实例， 也是父类的实例<br>不存在引用属性共享问题<br>可传参<br>函数可复用<br>缺点：调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</p>
<ul>
<li>class继承<br>是ES6新增的语法 直接class 创建一个类，使用extends来继承</li>
<li>实例继承</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>  instance.<span class="hljs-property">name</span> =  <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>  <span class="hljs-keyword">return</span> instance;<br>&#125;<br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat );<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Animal</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Cat</span>); <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure>

<p>特点：<br>不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果<br>缺点：<br>实例是父类的实例，不是子类的实例<br>不支持多继承</p>
<ul>
<li>拷贝继承<br>核心：循环父级</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> animal)&#123;<br>    <span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[p] = animal[p];<br>  &#125;<br>  <span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> =  <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Animal</span>); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Cat</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>特点：<br>支持多继承<br>缺点：<br>效率较低，内存占用高（因为要拷贝父类的属性）<br>无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）</p>
<ul>
<li>寄生组合继承<br>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params">name</span>)&#123;<br>  <span class="hljs-title class_">Animal</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">// 创建一个没有实例方法的类</span><br>  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Super</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;;<br>  <span class="hljs-title class_">Super</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>  <span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Super</span>();<br>  <span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Cat</span>;<br>&#125;)();<br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Animal</span>); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Cat</span>); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<p>特点：堪称完美<br>缺点：实现较为复杂</p>
<h2 id="函数的二义性"><a href="#函数的二义性" class="headerlink" title="函数的二义性"></a>函数的二义性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-comment">//调用的两种方式</span><br><span class="hljs-title function_">fn</span>() <span class="hljs-comment">// 当成普通函数来调用，把里面代码从头到尾走一遍</span><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>() <span class="hljs-comment">// 当成构造函数来调用，是为了创建一个对象</span><br></code></pre></td></tr></table></figure>

<p>写这个函数的时候不清楚这个函数将来会用什么样的方式来进行调用，有点像量子态<br>写这个函数可能是普通函数，也可能是构造函数，他处于一个叠加状态，只有你在调用他的时候才知道到底是什么函数<br>class是构造函数的语法糖，typeof class 是function</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 有一个普通函数a，我希望这个函数只能当成普通函数调用，而不应该使用new来调用</span><br><span class="hljs-comment">// es6提供一个语法叫new.target,这个表达式如果有值说明这个函数是通过new来调用的，反之就是普通函数调用的</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;can&#x27;t invoke with &#x27;new&#x27; &quot;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-title function_">a</span>() <span class="hljs-comment">// 没有问题</span><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">a</span>() <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure>

<h2 id="function变量提升和var变量提升哪个在前"><a href="#function变量提升和var变量提升哪个在前" class="headerlink" title="function变量提升和var变量提升哪个在前"></a>function变量提升和var变量提升哪个在前</h2><p>如果只是function和var，是函数在前<br>如果加上赋值是var在前，function在后</p>
<h2 id="var-let-const的区别"><a href="#var-let-const的区别" class="headerlink" title="var let const的区别"></a>var let const的区别</h2><ol>
<li>var let const的区别<br> const是常量，变量不能重复声明，只能赋值一次。不可以提升<br> let在作用域块里不能重复声明。<br> 变量父集是谁？window</li>
<li>暂时性死区<pre><code> 只要块里面有let或const，则当前作用域块形成暂时性死区，不再使用外部变量了。
</code></pre>
</li>
</ol>
<ul>
<li>只要带{}，都是块级作用域<pre><code>  var a=1;
  var b=2;
  function fn()&#123;
      console.log(a)//会报错，不会获取到全局var a=1;被let给锁死了
      let a=123456
      console.log(b);//b=2
  &#125;
  fn()
</code></pre>
</li>
</ul>
<h2 id="call，apply，bind改变指针，改变this指向方法"><a href="#call，apply，bind改变指针，改变this指向方法" class="headerlink" title="*call，apply，bind改变指针，改变this指向方法"></a>*call，apply，bind改变指针，改变this指向方法</h2><pre><code>call 参数：序列(什么是序列？单独的一个一个参数(this,1,2,3,4))
    call(this要指向对象，传参逐个列举(可能多个))
apply 参数：数组(this,[1,2,3,4])
    apply(this要指向对象，arguments)或fn.apply(this要指向对象，传参的数组)
bind 参数：序列 (bind返回的方法this是固定的)
</code></pre>
<h2 id="pay-attention"><a href="#pay-attention" class="headerlink" title="pay attention"></a>pay attention</h2><ol>
<li>setTimeout执行的时候还会执行一次次数</li>
<li>代码生命周期是代码的执行顺序，只有在这里面能用</li>
<li>为什么要变量提升？/变量提升的好处？因为防止出bug</li>
<li>作用域：<br> 全局：就是window<br> 局部：函数体，if体，for循环体，switch体</li>
<li>内部可以访问外部变量，外部可以访问内部鼠标</li>
<li>什么是变量？存储数据和表示值</li>
<li>什么是异步？同一时间做不同事情</li>
<li>什么是同步？在一个时间里只能执行一个事情</li>
</ol>
<h2 id="form-表单"><a href="#form-表单" class="headerlink" title="form 表单"></a>form 表单</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;form action=<span class="hljs-string">&quot;http://baidu.com&quot;</span> method=<span class="hljs-string">&quot;GET&quot;</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;my&quot;</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>与元素进行关联<br>    &lt;button type=<span class="hljs-string">&quot;button&quot;</span>&gt;按钮&lt;/button&gt;在表单中默认是submit类型<br>    &lt;button type=<span class="hljs-string">&quot;reset&quot;</span>&gt;重置&lt;/button&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;my&quot;</span>&gt;</span>//这样就与label关联上了</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<h2 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h2><ol>
<li>事件冒泡：父元素和子元素有相同的事件,当触发子元素事件时,会向上冒泡,同时也会触发父元素事件<br>特性：必须是嵌套结构，事件类型必须一致<br>事件委托：利用事件冒泡机制，给外层元素绑定事件。触发事件时，通过事件源检测到具体触发事件的元素<br> 例：ul有一万个绑定事件，只需要给ul绑定click事件，当点击其中某一个li的时候，事件冒泡特性会让ul捕获到click事件<br>什么是事件源？发生事件的对象，一般指某一具体组件，比如，用户点击某button，则此button为事件源<br>什么是组件？抽象概念，符合某种规范的类组合在一起就构成了组件<br>基于事件冒泡特性的委托<ul id="list"></ul>
click必须在同一个元素上按下然后释放
<button onclick="alert()">按钮</button></li>
</ol>
<h2 id="浏览器默认行为有哪些？如何取消"><a href="#浏览器默认行为有哪些？如何取消" class="headerlink" title="浏览器默认行为有哪些？如何取消"></a>浏览器默认行为有哪些？如何取消</h2><p>在form中按回车键就会提交表单；单击鼠标右键就会弹出context menu.<br>取消：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">element.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>    event = event || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>; <br> <br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">preventDefault</span>) &#123;  <span class="hljs-comment">// W3C variant </span><br>        event.<span class="hljs-title function_">preventDefault</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// IE&lt;9 variant:</span><br>        event.<span class="hljs-property">returnValue</span> = <span class="hljs-literal">false</span>;<br>    &#125;<br>	<span class="hljs-comment">//event.preventDefault?event.preventDefault():(event.returnValue = false);</span><br>&#125;<br><span class="hljs-comment">/* 或者 */</span><br>element.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>使用return false 要注意</li>
</ul>
<ol>
<li>jQuery有自己的事件处理层，也对处理程序做了封装，如果事件处理程序返回false，事件冒泡和浏览器默认事件都会被阻止。</li>
<li>使用原生javaScript，在事件处理程序中返回false只会阻止浏览器默认行为，而事件冒泡依然存在</li>
<li>浏览器默认行为和事件冒泡是相互独立的。阻止事件冒泡不会影响默认行为，反之亦然。</li>
</ol>
<ul>
<li>阻止a标签跳转？<a href="###"></a></li>
<li>如何阻止表单自动提交行为？把按钮改成button类型或者加点击事件在点击事件里清除默认行为</li>
</ul>
<h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><pre><code>合并assign
OBject.keys();把对象的属性名转成数组
Object.values()把值转成数组
Object.entries();
</code></pre>
<h2 id="js创建对象的几种方式"><a href="#js创建对象的几种方式" class="headerlink" title="js创建对象的几种方式"></a>js创建对象的几种方式</h2><p>无非就是使用内置对象或各种自定义对象，当然JSON也可以，写法很多，可以混合</p>
<ol>
<li>对象字面量的方式 person = {firstname:”Mark”,lastname:”Yun”}</li>
<li>用function来模拟无参的构造函数<br>function Person(){}<br>var person = new Person // 定义一个function，如果使用new实例化，该function可以看作是一个class<br>person.name = “Mark”<br>person.work = function(){alert(person.name+”hello”)}</li>
<li>用function来模拟参构造函数来实现（this关键字定义构造的上下文属性）<br>function Person(name) {<br> this.name = name<br> this.eat = function() {<pre><code> alert(&#39;我叫&#39;+this.name)
</code></pre>
 }<br>}<br>var ren = new Person(“佩奇”)<br>ren.eat() // 调用eat方法</li>
<li>用工厂方式来创建（内置对象）<br>var dog = new Object()<br>dog.name=”二哈”<br>dog.work = function() {<br> alert(“我的狗是”+dog.name)<br>}<br>dog.work()</li>
<li>用原型方式创建<br>function Dog(){}<br>Dog.prototype.name = “二哈”<br>Dog.prototype.eat = function(){alert(this.name+”哈哈哈”)}<br>var erha = new Dog()<br>erha.eat()</li>
<li>用混合方式来创建<br>function Car(name,price) {<br> this.name = name<br> this.price = price<br>}<br>Car.prototype.sell = function() {<br> alert(“我是”+this.name+”,卖”+this.price+”万”)<br>}<br>var camry = new Car(“凯美瑞”,27)<br>camry.sell()</li>
</ol>
<h2 id="javascript作用域？"><a href="#javascript作用域？" class="headerlink" title="javascript作用域？"></a>javascript作用域？</h2><p>作用域链的作用是保证执行环境里有权访问变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的</p>
<h2 id="谈谈this对象的理解"><a href="#谈谈this对象的理解" class="headerlink" title="谈谈this对象的理解"></a>谈谈this对象的理解</h2><p>this总是指向函数的直接调用者不是间接调用者<br>如果有new关键字，this指向new出来的那个对象<br>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象的window<br>this就是指的是当前对象</p>
<h2 id="什么是window对象？什么是document对象？"><a href="#什么是window对象？什么是document对象？" class="headerlink" title="什么是window对象？什么是document对象？"></a>什么是window对象？什么是document对象？</h2><p>window对象代表浏览器中的一个打开的窗口或者框架，window对象会在body或者framset每次出现时被自动创建，在客户端JavaScript中，window对象时全局对象，所有的表达式都在当前的环境中计算，要引用当前的窗口不需要特殊的语法，可以把那个窗口的属性当作全局变量使用</p>
<ul>
<li>window对象实现了核心javasc所定义的全局属性和方法</li>
<li>window对象的window属性和self属性饮用都是他自己<br>document对象<br>代表整个HTML文档，可以用来访问页面中的所有元素<br>document对象时window对象的一部分<br>可以通过window.document属性对其进行访问<br>HTMLDocument接口进行了扩展，定义HTML专用的属性和方法，很多属性和方法都是HTMLCollection对象，其中保存了对锚、表单、链接以及其他脚本元素的引用<h2 id="null和undefined区别"><a href="#null和undefined区别" class="headerlink" title="null和undefined区别"></a>null和undefined区别</h2>null表示一个对象被定义了，值为“空值”<br>undefined不存在这个值<br>undefined是一个表示“无”的原始值或者说表示“缺少值”，就是此处应有一个值，但还没有定义<br>例如:变量被声明了，但没有复制时就等于undefined</li>
<li>typeof null // object</li>
<li>验证null的时候一定要使用===，因为==无法分辨null和undefined<h2 id="写一个通用的事件侦听器函数"><a href="#写一个通用的事件侦听器函数" class="headerlink" title="写一个通用的事件侦听器函数"></a>写一个通用的事件侦听器函数</h2></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><br></code></pre></td></tr></table></figure>

<h2 id="“1”-”2”-”3”-map-parseInt-答案是多少？"><a href="#“1”-”2”-”3”-map-parseInt-答案是多少？" class="headerlink" title="[“1”,”2”,”3”].map(parseInt)答案是多少？"></a>[“1”,”2”,”3”].map(parseInt)答案是多少？</h2><p>[1,NaN,NaN]</p>
<ul>
<li>详细解析</li>
</ul>
<ol>
<li>因为parseInt需要两个参数(val,radix)<br> 其中radix表示解析时用的基数</li>
<li>map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。总共就两个参数，一个是回调函数，一个是指定对应的this。</li>
<li>map传了三个(element,index,array),对应radix不合法导致解析失败<br>element当前正在处理的元素；index当前元素的索引；array调用map的数组；<br>【至于第二个参数指定this】</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj对象&#x27;</span> &#125;<br><span class="hljs-keyword">var</span> newArr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>&#125;, obj)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newArr) <span class="hljs-comment">// [ &#x27;2obj对象&#x27;, &#x27;4obj对象&#x27;, &#x27;6obj对象&#x27; ]</span><br><span class="hljs-comment">/* 这里不能使用箭头函数的形式，因为箭头函数的this没有自己的this对象，内部的this就是定义时上层作用域中的this。 */</span><br></code></pre></td></tr></table></figure>
<ul>
<li>parseInt<br>parseInt(string, radix) 解析一个字符串并返回指定基数的十进制整数，radix 是 2-36 之间的整数，表示被解析字符串的基数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一个参数如果不是字符串，会被转换为字符串，且开头空白符会被忽略。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">10</span>)) <span class="hljs-comment">// 10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;            10&#x27;</span>)) <span class="hljs-comment">// 10</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;  11   22&#x27;</span>)) <span class="hljs-comment">// 11 /* 如果字符之间有空格，读取第一个 */	</span><br><br><span class="hljs-comment">// 超出这个范围就是NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">1</span>)) <span class="hljs-comment">// NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">36</span>)) <span class="hljs-comment">// 36</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">37</span>)) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 解析的字符串包含的数字超过 基数，返回NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-number">2</span>)) <span class="hljs-comment">// NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// NaN</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1324&#x27;</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 小数点后超过7位</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0.000005</span>)) <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0.0000005</span>)) <span class="hljs-comment">// 5</span><br><span class="hljs-comment">/* 原因是 0.0000005 不是字符串，会被toString() =&gt; 5e-7 */</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-number">0.0000005</span>).<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">// 5e-7</span><br></code></pre></td></tr></table></figure>

<p>所以这道题可以解析成这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-number">0</span>,[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>])<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-number">1</span>,[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>])<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-number">2</span>,[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>])<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    parseInt没有第三个参数，所以可以忽略。</span><br><span class="hljs-comment">    基数为0 =&gt; 默认10进制</span><br><span class="hljs-comment">    解析的字符串包含的数字超过基数，返回NaN</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h2 id="闭包的一个漏洞"><a href="#闭包的一个漏洞" class="headerlink" title="闭包的一个漏洞"></a>闭包的一个漏洞</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 如何在不改变上面代码的情况下，修改obj对象</span><br><span class="hljs-keyword">var</span> o = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> obj = &#123;<br>        <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br>        <span class="hljs-attr">b</span>:,<br>    &#125;;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">get</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">k</span>) &#123;<br>            <span class="hljs-keyword">return</span> obj[k]<br>        &#125;<br>    &#125;<br>&#125;)() <span class="hljs-comment">// 自执行函数</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;a&#x27;</span>)) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;b&#x27;</span>)) <span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 这是一个典型的闭包场景，这样做的目的是屏蔽obj,不能让外边直接访问它，只能读取他的某一个属性，保证这个对象的完整</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;valueOf&#x27;</span>))<span class="hljs-comment">// [Function:valueOf] // 这是obj的原型，也就是访问到那个函数，对象上的valueOf函数返回他自身，返回这个obj对象本身，但是</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;valueOf&#x27;</span>)())<span class="hljs-comment">// 这样直接调用会报错</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    obj.valueOf()我们本来应该通过obj，但现在是通过这个表达式，拿到valueOf这个函数本身，然后用函数本身去调用，那这个时候this指向会出问题</span><br><span class="hljs-comment">    obj.valueOf() this指向obj</span><br><span class="hljs-comment">    但o.get(&#x27;valueOf&#x27;)()，这样调用this指向全局，在严格模式下会指向undefined</span><br><span class="hljs-comment">    相当于</span><br><span class="hljs-comment">    const valueOf = Object.prototype.valueOf;</span><br><span class="hljs-comment">    valueOf()</span><br><span class="hljs-comment">    如果在函数里面返回一个函数调用而不是返回一个成员get:function(k) &#123;</span><br><span class="hljs-comment">            return obj[k]()</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    那o.get(&#x27;valueOf&#x27;)()就可以，相当于直接obj调valueOf</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,<span class="hljs-string">&#x27;abc&#x27;</span>,&#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 加一个属性abc,把这个属性变成一个访问器，之后只要一读这个属性，就相当于是运行这个函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span> <span class="hljs-comment">// this就是哪个对象在读abc，this就是哪个对象</span><br>    &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)) <span class="hljs-comment">// &#123;a:1,b:2&#125;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    调用get函数传来个abc,读取obj它的abc属性，他没有abc，没有他就会读哪儿?读到Object.prototype上的abc,那么他上面有abc，是个函数。于是return this 得到的是obj本身</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 不改变上述代码修改obj</span><br><span class="hljs-keyword">var</span> ob2= o.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) <br>obj2.<span class="hljs-property">c</span> = <span class="hljs-number">2</span><br>obj2.<span class="hljs-property">a</span>= assdhghfj<br></code></pre></td></tr></table></figure>

<ul>
<li>如何防止上述方案</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 在函数里进行验证，看一下这个属性是不是他本身的属性</span><br><span class="hljs-keyword">var</span> o = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>:,<br>&#125;;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">get</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">k</span>) &#123;<br>            <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(k)) &#123;<br>                <span class="hljs-keyword">return</span> obj[k]<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// 这个就是省略了else</span><br>        &#125;<br>    &#125;<br>&#125;)() <br><span class="hljs-comment">// 2. 如果对象不需要用到原型上的任何东西</span><br><span class="hljs-keyword">var</span> o = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>:,<br>&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(obj,<span class="hljs-literal">null</span>) <span class="hljs-comment">// 把obj原型设置为null</span><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">get</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">k</span>) &#123;<br>              <span class="hljs-keyword">return</span> obj[k]<br>        &#125;<br>    &#125;<br>&#125;)() <br></code></pre></td></tr></table></figure>

<h2 id="等号运算规则"><a href="#等号运算规则" class="headerlink" title="等号运算规则"></a>等号运算规则</h2><p>== </p>
<ol>
<li>类型相同————比较值</li>
<li>类型不同</li>
</ol>
<ul>
<li>均为原始————转换为数字比较</li>
<li>一端原始一端对象————对象原始后比较（先调用valueOf,若无法转换成原始值，在调用toString）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">valueOf</span>()) <span class="hljs-comment">// &#123;&#125;还是一个对象，得不到原始</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">toString</span>()) <span class="hljs-comment">//[object Object]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj == <span class="hljs-number">1</span>) <span class="hljs-comment">// false</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">valueOf</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj == <span class="hljs-number">1</span>) <span class="hljs-comment">// true </span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>特殊<br>undefined== null<br>NaN!=NaN</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ?位置应该怎么写才能输出true</span><br><span class="hljs-keyword">var</span> a= ?<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>    a==<span class="hljs-number">1</span> &amp;&amp;<br>    a==<span class="hljs-number">2</span> &amp;&amp;<br>    a==<span class="hljs-number">3</span><br>)<br><span class="hljs-comment">// 答案</span><br><span class="hljs-keyword">var</span> a = &#123;<br>    <span class="hljs-attr">n</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">valueOf</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span>++<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="优化代码分支"><a href="#优化代码分支" class="headerlink" title="优化代码分支"></a>优化代码分支</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">if</span>(name === <span class="hljs-string">&#x27;老牛&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cow&#x27;</span>)<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(name === <span class="hljs-string">&#x27;老鼠&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mouse&#x27;</span>)<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(name === <span class="hljs-string">&#x27;老虎&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tiger)<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;爱谁谁&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-title function_">speak</span>(<span class="hljs-string">&#x27;老牛&#x27;</span>)<br><br><span class="hljs-comment">// 上述代码分支太多</span><br><br><span class="hljs-comment">// 共同特点：这个东西等于某一个值的时候，去输出另一个值的时候；再等于一个值再去输出另一个值。</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">const</span> map = &#123;<span class="hljs-comment">// 可以在分支前使用一个映射</span><br>        老牛:<span class="hljs-string">&#x27;cow&#x27;</span>,<br>        老鼠:<span class="hljs-string">&#x27;mouse&#x27;</span>,<br>        老虎:<span class="hljs-string">&#x27;tiger&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(map[name]) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map[name])<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;爱谁谁&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-title function_">speak</span>(<span class="hljs-string">&#x27;老牛&#x27;</span>)<br><br><span class="hljs-comment">// 若上述改进代码，每一个属性对应不同分支</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">const</span> map = &#123;<span class="hljs-comment">// 可以在分支前使用一个映射</span><br>        老牛:<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cow&#x27;</span>),<br>        老鼠:<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;写入文件:&#x27;</span>,<span class="hljs-string">&#x27;mouse&#x27;</span>),<br>        老虎:<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;上传服务器&#x27;</span>,<span class="hljs-string">&#x27;tiger&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(map[name]) &#123;<br>        map[name]() <span class="hljs-comment">// 调用相应函数</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;爱谁谁&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-title function_">speak</span>(<span class="hljs-string">&#x27;老牛&#x27;</span>)<br><br><span class="hljs-comment">// 再复杂一点，比如这个条件不一定都是判断name这个参数,下面这种情况</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">if</span>(name.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;牛&#x27;</span>)) &#123;<br>        onsole.<span class="hljs-title function_">log</span>(name + <span class="hljs-string">&#x27;cow&#x27;</span>)<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(name.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;虎&#x27;</span>) &amp;&amp; name.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name + <span class="hljs-string">&#x27;tiger&#x27;</span>)<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(name.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;猫&#x27;</span>) &amp;&amp; !name.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;狗&#x27;</span>)) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name + <span class="hljs-string">&#x27;cat&#x27;</span>)<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;爱谁谁&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-title function_">speak</span>(<span class="hljs-string">&#x27;东北虎&#x27;</span>)<br><br><span class="hljs-comment">// 尽量变成一个映射，但这映射需要用元组</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-keyword">const</span> map = [<br>        [<br>            <span class="hljs-function">() =&gt;</span> name.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;牛&#x27;</span>), <span class="hljs-comment">// 表示条件，函数返回一个true/false，true表示条件成立，false表示不成立</span><br>            <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name+<span class="hljs-string">&#x27;cow&#x27;</span>) <span class="hljs-comment">// 表示满足条件后要做的事</span><br>        ],<br>        [<br>            <span class="hljs-function">() =&gt;</span> name.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;虎&#x27;</span>) &amp;&amp; name.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">3</span>,<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name + <span class="hljs-string">&#x27;tiger&#x27;</span>)<br>        ],<br>        [<br>            <span class="hljs-function">() =&gt;</span> name.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;猫&#x27;</span>) &amp;&amp; !name.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;狗&#x27;</span>),<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name + <span class="hljs-string">&#x27;cat&#x27;</span>)<br>        ]<br>    ]<br>    <span class="hljs-comment">/*遍历地去找到条件满足的那一项，然后运行他相应的函数即可 */</span><br>    <span class="hljs-keyword">const</span> target = map.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m[<span class="hljs-number">0</span>]()) <span class="hljs-comment">// 通过数组里的函数来找到满足条件的一项，可以找到每个数组的第一项，然后运行这个函数</span><br>    <span class="hljs-keyword">if</span>(target) &#123;<br>        target[<span class="hljs-number">1</span>](); <span class="hljs-comment">// 条件满足运行数组的第二项</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;爱谁谁&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-title function_">speak</span>(<span class="hljs-string">&#x27;东北虎&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="进制问题"><a href="#进制问题" class="headerlink" title="进制问题"></a>进制问题</h2><p>toFixed结果可能会欺骗你<br>存储、运算、显示都可能不准确</p>
<ol>
<li>存储一个十进制的小数，把它变成二进制可能出现无限循环</li>
</ol>
<ul>
<li>0.2.toString(2) 0.0011001100110011… 变成了00110011一直循环，但计算机存储能力有限，有一个固定精度，到了这个精度后后面的数字他就不要了</li>
<li>比如 0.00110011 0011 就到这里，若最后一位后一位是0，那么最后一位就是0，若是1就往前进1</li>
<li>存储后得到的结果不是0.19999，而是0.20000</li>
<li>检验：0.2.toPrecision(20) 0.200000</li>
<li>0.20000.toString(2) 0.0011001100110011…<br>0.199999.toString(2) 0.0011001100110011…<br>0.200000 === 0.199999 // true</li>
</ul>
<ol start="2">
<li>运算<br>运算是用存储的二进制进行运算的，没有办法用十进制计算，十进制是最终给你显示出来的结果</li>
</ol>
<ul>
<li>在JS中为什么0.2 + 0.1 &gt; 0.3</li>
<li>因为在JS中，浮点数是使用64位固定长度来表示的，其中的1位表示符号位，11位用来表示指示位，剩下的52位尾数位<br>而0.1转为二进制是一个无限循环数0.00011001100110011…..(1100循环)<br>由于只有52位表示尾数位，所以会出现精度缺失，把它存到内存中再取出来转换成十进制就不是原来的0.1了，就变成了0.10000000000000005551115123126</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//0.1 和 0.2 都转化成二进制后再进行运算</span><br><span class="hljs-number">000011001100110011001100110011001100110011001100110011010</span><br><span class="hljs-number">00011001100110911001109110011001100110011001100110011010</span><br><span class="hljs-number">0.0100110011001100119011001100110011091109110911001100111</span><br><span class="hljs-comment">// 转成十进制正好是 0.30900090009009004</span><br></code></pre></td></tr></table></figure>

<p>0.1后面是01，在入，0.2最后也是入，两个都在入，那么不仅是不精确而是更不精确</p>
<ul>
<li>为什么0.2+0.3=0.5呢？</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 0.2 和 0.3 都转化为二进制后再进行计算</span><br><span class="hljs-number">0.001100110911001109110011091100110011001100110011001101</span><br><span class="hljs-number">00100110011901100110011001100110911091109110011001101</span> <br><span class="hljs-number">0.1000000000000000000000000000000000000000000000000091</span> <span class="hljs-comment">//尾数为大于52位</span><br><br><span class="hljs-comment">// 而实际取值只取52位尾数位，就变成了</span><br><span class="hljs-number">0.1000000000000000000000000000000000000000000000000000</span><span class="hljs-comment">//0.5</span><br></code></pre></td></tr></table></figure>
<p>0.2和0.3分别转换为二进制进行计算: 在内存中，它们的尾数位都是等于52位的，而他们相加必定大于52位，而他们相加又恰巧前52位尾数都是0，也就是0.5<br>0.5.toString(2) 0.1 精确<br>在计算过程中出现抵消，0.2在最后的位置进行了入操作也就是进1，0.3进行了舍操作，也就是0，一个舍一个入，刚好抵消，就精确了</p>
<ul>
<li>那0.2-0.3 与 0.3 - 0.2精确吗</li>
</ul>
<p>0.3是舍操作，0.2是入操作，它比原来的0.3小一点，0.2比原来的0.2大一点，那么减出来也会更不精确，更小一点的不精确 0.099999<br>0.2 - 0.3 减出来也会更不精确，更大一点的不精确 -0.99999<br>3. 显示</p>
<ul>
<li>那既然不是0.1了，为什么console.log打印出来还是0.1？<br>在console.log 的时候会二进制转化成十进制，十进制再会转为字符串的形式，在转换过程中发生了近似取值，所以打印出来的是一个近似值的字符串<br>浏览器在显示的时候会做一个近似处理</li>
</ul>
<ol start="4">
<li>toFixed()<br>toFixed()实现原理是先运算再显示，而无论是运算还是显示都是可能不精确</li>
<li>55.toFixed(1) // 2.5<br>因为</li>
<li>55.toString(2) ‘10.10001100110011’</li>
<li>55.toPrecision(100) ‘2.5499999’保留1位就是2.5</li>
</ol>
<h2 id="浏览器的进程模型"><a href="#浏览器的进程模型" class="headerlink" title="浏览器的进程模型"></a>浏览器的进程模型</h2><ol>
<li>何为进程？<br>程序运行需要有它自己的专属空间，可以把这块内存空间简单的理解为进程<br>每一个应用都有一个进程，进程之间相互独立，即使通信也需要双方同意</li>
<li>浏览器有哪些进程和线程？<br>浏览器是一个多进程多线程的应用程序<br>浏览器内部工作极其复杂，为了避免相互影响，减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程</li>
</ol>
<ul>
<li>渲染进程不适合多线程来处理</li>
</ul>
<h2 id="浏览器页面加载过程"><a href="#浏览器页面加载过程" class="headerlink" title="浏览器页面加载过程"></a>浏览器页面加载过程</h2><ol>
<li>根据DNS服务器得到域名的IP地址</li>
<li>向这个IP的机器发送HTTP请求</li>
<li>服务器收到、处理并返回HTTP请求</li>
<li>浏览器得到返回内容</li>
</ol>
<h2 id="浏览器会解析三个东西"><a href="#浏览器会解析三个东西" class="headerlink" title="浏览器会解析三个东西"></a>浏览器会解析三个东西</h2><ol>
<li>一是HTML/SVG/XHTML，HTML字符串描述了一个页面的结构，浏览器会把HTML结构字符串解析转换DOM树形结构。</li>
<li>二是CSS，解析CSS会产生CSS规则树，它和DOM结构比较像</li>
<li>三是Javascript脚本，等到Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree。</li>
<li>解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree</li>
</ol>
<ul>
<li>Rendering Tree 渲染树并不等同于DOM树，渲染树只会包括需要显示的节点和这些节点的样式信息。</li>
<li>CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element（也就是每个Frame）。</li>
<li>然后，计算每个Frame 的位置，这又叫layout和reflow过程。</li>
</ul>
<ol start="5">
<li>最后通过调用操作系统Native GUI的API绘制。</li>
</ol>
<h2 id="渲染主线程是如何工作的？"><a href="#渲染主线程是如何工作的？" class="headerlink" title="渲染主线程是如何工作的？"></a>渲染主线程是如何工作的？</h2><ol>
<li>最开始的时候，渲染主线程会进入一个无限循环 for(;;)conosle.log(1)<br>for(;;)就是for(var i=0;i&lt;10;i++)<br>也就是whilre(true) {条件永远为真}</li>
<li>每一次循环都会检查消息队列中是否有任务存在，如果有就取出第一个任务执行，执行完后进入下一次循环，如果没有进入休眠状态</li>
</ol>
<h2 id="如何理解JS的异步？"><a href="#如何理解JS的异步？" class="headerlink" title="如何理解JS的异步？"></a>如何理解JS的异步？</h2><p>js是一门单线程语言，这是因为它运行在浏览器渲染主线程中，而主线程只有一个<br>而渲染主线程承担诸多工作，渲染页面、执行JS都在其中运行<br>如果用同步的方式极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行<br>这样以来一方面会导致繁忙的主线程白白消耗时间，另一方面导致页面无法及时更新<br>所以用异步来避免<br>具体做法是？当某些任务发生时，比如定时器、网络、事件监听主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行</p>
<h2 id="js的事件循环"><a href="#js的事件循环" class="headerlink" title="js的事件循环"></a>js的事件循环</h2><p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式<br>在谷歌源码中它开启一个不会结束的for循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需在合适的时候将任务加入到队列末尾即可<br>过去把任务分为宏任务与微任务，但这种说法目前无法满足复杂的浏览器环境<br>W3C官网解释：每个任务有不同的任务类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在每一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微任务，微任务队列具有最高的优先级，必须优先调度执行</p>
<ul>
<li>单线程是异步产生的原因，事件循环是异步的实现方式</li>
</ul>
<h2 id="JS计时器能做到精确计时吗？"><a href="#JS计时器能做到精确计时吗？" class="headerlink" title="JS计时器能做到精确计时吗？"></a>JS计时器能做到精确计时吗？</h2><p>不能<br>因为</p>
<ol>
<li>计算机硬件没有原子钟，无法做到精确计时</li>
<li>操作系统计算函数本身就有少量的偏差，由于JS的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li>
<li>根据W3C标准，浏览器实现计时器，如果嵌套层级超过5层，则会带有4毫秒的最少时间，这样在计时时间少于4毫秒又带来了偏差</li>
<li>受事件循环影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li>
</ol>
<div id="paginator"></div></div><div id="post-footer"></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧</a><a id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">John Doe</a></h1><div id="description"><p>支持大家讨论交流</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.</span> <span class="toc-text">轮播图实现思路</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">事件轮询机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%85%88%E5%90%8E-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">宏任务微任务先后 执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B1%E4%BB%80%E4%B9%88%E5%86%85%E6%A0%B8%E6%9D%A5%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">由什么内核来处理？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">练习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E7%BB%98%E5%92%8C%E9%87%8D%E6%8E%92%EF%BC%9F"><span class="toc-number"></span> <span class="toc-text">什么是重绘和重排？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">面向对象和面向过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%A5%E9%94%99"><span class="toc-number"></span> <span class="toc-text">报错</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">严格模式，混杂模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#call%EF%BC%8Capply%EF%BC%8Cbind"><span class="toc-number"></span> <span class="toc-text">call，apply，bind</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-number"></span> <span class="toc-text">堆和栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#this%E6%8C%87%E5%90%91"><span class="toc-number"></span> <span class="toc-text">this指向</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E5%92%8C%E7%9C%9F%E5%AE%9EDOM%E5%8C%BA%E5%88%AB"><span class="toc-number"></span> <span class="toc-text">虚拟DOM和真实DOM区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">检测数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">数组方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">判断变量是不是数组，有哪些方法？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">如何判断一个对象是空对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%94%B9"><span class="toc-number">3.</span> <span class="toc-text">const对象的属性是否可以更改</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number"></span> <span class="toc-text">浅拷贝，深拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number"></span> <span class="toc-text">字面量对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number"></span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-is-%E4%B8%8E-%EF%BC%8C-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">Object.is()与&#x3D;&#x3D;，&#x3D;&#x3D;&#x3D;区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%AD%98%E4%B8%8D%E5%AD%98%E5%9C%A8"><span class="toc-number">3.</span> <span class="toc-text">属性存不存在</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E5%92%8CBOM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">DOM和BOM的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">数字格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99"><span class="toc-number">5.1.</span> <span class="toc-text">正则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">6.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#valueOf-NaN"><span class="toc-number">7.</span> <span class="toc-text">valueOf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#void"><span class="toc-number">8.</span> <span class="toc-text">void</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E6%85%A2%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">9.</span> <span class="toc-text">首屏加载慢怎么解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%8F%96%E6%B6%88%E4%BA%8B%E4%BB%B6%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-number">10.</span> <span class="toc-text">如何正确取消事件默认行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3"><span class="toc-number">11.</span> <span class="toc-text">console命令详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">生成器函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#generator%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.1.</span> <span class="toc-text">generator函数与构造函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BTW%E2%80%94-CSP"><span class="toc-number">12.2.</span> <span class="toc-text">BTW— CSP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-const-var"><span class="toc-number">13.</span> <span class="toc-text">let const var</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%9B%91%E5%90%AC%E5%85%83%E7%B4%A0%E9%87%8D%E5%8F%A0"><span class="toc-number">14.</span> <span class="toc-text">一个监听元素重叠</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BTW%E2%80%94React"><span class="toc-number">14.1.</span> <span class="toc-text">BTW—React</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E9%A1%B5%E9%9D%A2%E8%AE%A1%E6%97%B6%E5%99%A8%E5%A4%B1%E6%B4%BB%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">15.</span> <span class="toc-text">后台页面计时器失活怎么解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#three-js%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number">15.1.</span> <span class="toc-text">three.js如何处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%AD%A4%E4%B9%8B%E5%A4%96%E5%8F%AF%E4%BB%A5%E8%AF%95%E8%AF%95webworker%E6%9D%A5%E8%A7%A3%E5%86%B3"><span class="toc-number">15.2.</span> <span class="toc-text">除此之外可以试试webworker来解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99promise-all"><span class="toc-number">16.</span> <span class="toc-text">手写promise.all</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E7%9A%84%E5%BC%82%E6%AD%A5%E5%9F%BA%E7%A1%80%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">18.</span> <span class="toc-text">js的异步基础是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%88%A4%E6%96%AD%E7%89%88%E6%9C%AC%E5%8F%B7%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">19.</span> <span class="toc-text">写一个函数判断版本号的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">20.</span> <span class="toc-text">JS继承的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="toc-number">21.</span> <span class="toc-text">函数的二义性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#function%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8Cvar%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%93%AA%E4%B8%AA%E5%9C%A8%E5%89%8D"><span class="toc-number">22.</span> <span class="toc-text">function变量提升和var变量提升哪个在前</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#var-let-const%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">23.</span> <span class="toc-text">var let const的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call%EF%BC%8Capply%EF%BC%8Cbind%E6%94%B9%E5%8F%98%E6%8C%87%E9%92%88%EF%BC%8C%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91%E6%96%B9%E6%B3%95"><span class="toc-number">24.</span> <span class="toc-text">*call，apply，bind改变指针，改变this指向方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pay-attention"><span class="toc-number">25.</span> <span class="toc-text">pay attention</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#form-%E8%A1%A8%E5%8D%95"><span class="toc-number">26.</span> <span class="toc-text">form 表单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1"><span class="toc-number">27.</span> <span class="toc-text">冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%A6%82%E4%BD%95%E5%8F%96%E6%B6%88"><span class="toc-number">28.</span> <span class="toc-text">浏览器默认行为有哪些？如何取消</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">29.</span> <span class="toc-text">对象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">30.</span> <span class="toc-text">js创建对象的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javascript%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">31.</span> <span class="toc-text">javascript作用域？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88this%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">32.</span> <span class="toc-text">谈谈this对象的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFwindow%E5%AF%B9%E8%B1%A1%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFdocument%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">什么是window对象？什么是document对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB"><span class="toc-number">34.</span> <span class="toc-text">null和undefined区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%99%A8%E5%87%BD%E6%95%B0"><span class="toc-number">35.</span> <span class="toc-text">写一个通用的事件侦听器函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C1%E2%80%9D-%E2%80%9D2%E2%80%9D-%E2%80%9D3%E2%80%9D-map-parseInt-%E7%AD%94%E6%A1%88%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">[“1”,”2”,”3”].map(parseInt)答案是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%80%E4%B8%AA%E6%BC%8F%E6%B4%9E"><span class="toc-number">37.</span> <span class="toc-text">闭包的一个漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%8F%B7%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">38.</span> <span class="toc-text">等号运算规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%94%AF"><span class="toc-number">39.</span> <span class="toc-text">优化代码分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98"><span class="toc-number">40.</span> <span class="toc-text">进制问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">41.</span> <span class="toc-text">浏览器的进程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">42.</span> <span class="toc-text">浏览器页面加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E8%A7%A3%E6%9E%90%E4%B8%89%E4%B8%AA%E4%B8%9C%E8%A5%BF"><span class="toc-number">43.</span> <span class="toc-text">浏览器会解析三个东西</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">44.</span> <span class="toc-text">渲染主线程是如何工作的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3JS%E7%9A%84%E5%BC%82%E6%AD%A5%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">如何理解JS的异步？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">46.</span> <span class="toc-text">js的事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E8%AE%A1%E6%97%B6%E5%99%A8%E8%83%BD%E5%81%9A%E5%88%B0%E7%B2%BE%E7%A1%AE%E8%AE%A1%E6%97%B6%E5%90%97%EF%BC%9F"><span class="toc-number">47.</span> <span class="toc-text">JS计时器能做到精确计时吗？</span></a></li></ol></div><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">6</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">1</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">5</span></div></section></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {code.findCode();
document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>