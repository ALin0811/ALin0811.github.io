<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>express | ALin的个人博客</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ALin的个人博客" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>express</h1></div><hr><div id="post-content"><h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>express基于node.js平台，快速，开放，极简的web开发框架<br>与node.js中的http类似，专门用来创建web服务器的</p>
<ul>
<li>express 的本质就是一个npm上的第三方包，提供了快速创建web服务器的便捷方法</li>
</ul>
<h3 id="http与express对比"><a href="#http与express对比" class="headerlink" title="http与express对比"></a>http与express对比</h3><p>http内置模块用起来很复杂，开发效率低<br>express是基于内置的http模块进一步封装出来的，能够极大的提高开发效率<br>http 与 express 之间的关系类似于 WebAPI 和 jQuery 后者是基于前者进一步封装出来的</p>
<h3 id="express-做什么？"><a href="#express-做什么？" class="headerlink" title="express 做什么？"></a>express 做什么？</h3><p>对于前端，常见两种服务器</p>
<ol>
<li>web网站服务器 ：专们对外提供web网页资源的服务器</li>
<li>API接口服务器 ：专们对外提供API接口的服务器</li>
</ol>
<h3 id="express基本使用"><a href="#express基本使用" class="headerlink" title="express基本使用"></a>express基本使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 导入express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 2. 创建web服务器</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><span class="hljs-comment">// 4. 监听客户的GET 和 POST 请求，并向客户端响应具体内容</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">//调用express提供的res.send()方法，向客户端响应一个json对象</span><br>  res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zs&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">20</span>,<span class="hljs-attr">gender</span>:<span class="hljs-string">&#x27;男&#x27;</span>&#125;)<br>  <span class="hljs-comment">// 通过req.query 可以获取到客户端发送过来的 查询参数</span><br>&#125;)<br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 调用express提供的res.send()方法，向客户端响应一个文本字符串 </span><br>  <span class="hljs-comment">// res.send() 既可以响应json对象，也可以是文本字符串</span><br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;请求成功&#x27;</span>)<br>  <br>&#125;)<br><span class="hljs-comment">// 3. 调用app.listen(端口号，启动成功后的回调函数)，启动服务器</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="获取URL中的动态参数"><a href="#获取URL中的动态参数" class="headerlink" title="获取URL中的动态参数"></a>获取URL中的动态参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// url地址中 :参数名 匹配到的动态参数  可以是多个比如/user/:id/:name</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/:id&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * req.params 默认是一个空对象</span><br><span class="hljs-comment">   * 里面存放着通过：动态匹配到的参数值</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(req.<span class="hljs-property">params</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h3><p>express提供了一个非常好用的函数，express.static()，通过它可以非常方便的创建一个静态资源服务器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 通过如下代码，可以将public目录下的图片、css文件、javascript文件对外开放访问了</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<br><span class="hljs-comment">// 2. 托管多个，就是多次调用express.static() 函数，根据目录的添加顺序查找所需的文件</span><br><span class="hljs-comment">// 3. 挂载路径前缀  如果希望托管的静态资源访问路径之前，挂载路径前缀，可以用</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/public&#x27;</span>,express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>))<br></code></pre></td></tr></table></figure>
<ul>
<li>把node命令替换成nodemon来启动项目，好处在于，代码被修改后，会被nodemon监听到，从而实现自动重启项目的效果</li>
</ul>
<h2 id="express路由"><a href="#express路由" class="headerlink" title="express路由"></a>express路由</h2><p>客户端的请求与服务器处理函数之间的映射关系</p>
<ul>
<li>由三部分组成，分别是请求的类型，请求的url地址，处理函数<br>app.method(path,handler)</li>
<li>但为了方便模块化管理，不建议把路由挂载到app上，推荐将路由抽离为单独的模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建对应的.js文件</span><br><span class="hljs-comment">// 2. 调用express.Router() 函数创建路由对象</span><br><span class="hljs-comment">// 3. 向路由对象上挂载具体的路由</span><br><span class="hljs-comment">// 4. 使用module.exports 向外共享路由对象</span><br><span class="hljs-comment">// 5. 使用app.use() 函数注册路由模块</span><br><br><span class="hljs-comment">// router.js</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> router = express.<span class="hljs-title class_">Router</span>()<br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user/list&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>) &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Get user list&#x27;</span>)<br>&#125;)<br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user/add&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>) &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Add new user&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router<br><br><span class="hljs-comment">// </span><br><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router.js&#x27;</span>)<br>app.<span class="hljs-title function_">use</span>(router) <span class="hljs-comment">// app.use()函数的作用,就是来注册全局中间件</span><br></code></pre></td></tr></table></figure>

<h3 id="注册路由模块"><a href="#注册路由模块" class="headerlink" title="注册路由模块"></a>注册路由模块</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 导入路由模块</span><br><span class="hljs-keyword">const</span> userRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router/user.js&#x27;</span>)<br><span class="hljs-comment">// 2. 使用app.use()注册路由模块</span><br>app.<span class="hljs-title function_">use</span>(userRouter)<br><br><span class="hljs-comment">// 为路由模块添加前缀</span><br><span class="hljs-comment">// 类似托管静态资源，为静态资源统一挂载访问前缀一样</span><br><span class="hljs-comment">// 1. 导入路由模块</span><br><span class="hljs-keyword">const</span> userRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./router/user.js&#x27;</span>)<br><span class="hljs-comment">// 2. 使用app.use()注册路由模块</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>,userRouter)<br></code></pre></td></tr></table></figure>

<h2 id="express中间件"><a href="#express中间件" class="headerlink" title="express中间件"></a>express中间件</h2><p>express中间件调用流程<br>当一个请求到达express的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理</p>
<pre><code>  请求
</code></pre>
<p>客 ——————————&gt;  中间件1 ——————————&gt; 中间件2<br>户                                   ｜<br>端 —— 处理完毕响应这次请求 &lt;—————————— 中间件n<br>  响应</p>
<ul>
<li>express中间件本质上就是一个function处理函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>) &#123;<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>中间件函数的形参列表中，必须包含next参数。而路由处理函数中只包含req和res</li>
</ul>
<h3 id="next函数的作用"><a href="#next函数的作用" class="headerlink" title="next函数的作用"></a>next函数的作用</h3><p>是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由<br>调用next()函数之后不要再写额外的代码，防止代码逻辑混乱</p>
<h3 id="全局生效的中间件"><a href="#全局生效的中间件" class="headerlink" title="全局生效的中间件"></a>全局生效的中间件</h3><p>客户端发起的任何请求，到达服务器之后，都会触发的中间件，叫做全局生效的中间件<br>通过调用app.use(中间件函数)，即可定义一个全局生效的中间件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nw = <span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;简单中间件函数&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;<br><span class="hljs-comment">// 全局生效的中间件</span><br>app.<span class="hljs-title function_">use</span>(nw)<br></code></pre></td></tr></table></figure>

<h3 id="中间件的作用"><a href="#中间件的作用" class="headerlink" title="中间件的作用"></a>中间件的作用</h3><p>多个中间件之间，共享同一份req和res,基于这样的特性，我们可以在上游的中间件中，统一为req和res对象添加自定义的属性或方法，供下游中间件或路由进行使用</p>
<h3 id="定义多个全局中间件"><a href="#定义多个全局中间件" class="headerlink" title="定义多个全局中间件"></a>定义多个全局中间件</h3><p>app.use()连续定义多个全局中间件，客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用来第一个全局中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;调用来第二个全局中间件&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="定义局部生效的中间件"><a href="#定义局部生效的中间件" class="headerlink" title="定义局部生效的中间件"></a>定义局部生效的中间件</h3><p>不使用app.use() 定义的中间件，叫做局部生效的中间件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> nw1 = <span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;这是中间件函数&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;<br><span class="hljs-comment">// nw1这个函数只在“当前路由中生效”，这种用法属于“局部生效的中间件”</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,nw1,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>) &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// nw1这个函数不会影响下面这个路由</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>) &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;User page&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 定义多个局部，有两种方法</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,nw1,nw2,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>) &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page&#x27;</span>)<br>&#125;)<br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,[nw1,nw2],<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>) &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h3><p>五大类</p>
<ol>
<li>应用级别中间件<br>通过app.use(),app.get(),app.post(),绑定到app实例上的中间件都是</li>
<li>路由级别中间件<br>绑定到express.Router()实例上的中间件。用法与1无甚区别，只不过一个是绑定在app实例上，另一个绑定在router实例上</li>
<li>错误级别中间件<br>捕获整个项目中发生的异常错误，从而防止项目异常崩溃</li>
</ol>
<ul>
<li>格式，必须包含四个参数 (err,req,res,next) </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;服务器内部发生了错误&#x27;</span>) <span class="hljs-comment">// 抛出一个自定义的错误</span><br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Home page&#x27;</span>)<br>&#125;)<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err,req,res,next</span>) &#123; <br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;发生了错误&#x27;</span> + err.<span class="hljs-property">message</span>) <span class="hljs-comment">// 在服务器中打印错误消息</span><br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Error!&#x27;</span> + err.<span class="hljs-property">message</span>) <span class="hljs-comment">// 向客户端响应错误相关内容</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li>错误路由中间件必须注册在所有路由之后</li>
</ul>
<ol start="4">
<li>express内置中间件<br>express.static 快速托管静态资源的内置中间件，例如：HTML文件、图片、CSS样式<br>express.json 解析JSON格式的请求体数据 (有兼容性，仅在4.16.0+ 版本中使用)</li>
</ol>
<ul>
<li>在服务器端可以通过req.body 来获取JSON格式的表单数据和url-encoded格式的数据<br>express.urlencoded 解析URL-encoded 格式的请求体数据 (有兼容性，仅在4.16.0+ 版本中使用)</li>
<li>app.use(express.urlencoded({extended:false}))</li>
<li>extended:false 表示不使用第三方的解析方式，只用自身的解析方式，如果是true就是使用第三方解析方式</li>
<li>基于第三方中间件body-parser进一步封装出来的</li>
</ul>
<ul>
<li>如果没有任何解析表单数据的中间件，则req.body默认等于undefined</li>
</ul>
<ol start="5">
<li>第三方中间件<br>非express官方内置的，由第三方开发出来的中间件</li>
</ol>
<ul>
<li>注意，除了错误级别的中间件，其他中间件，必须在路由之间进行配置</li>
</ul>
<h3 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h3><p>自己手动模拟一个类似于express.urlencoded 这样的中间件，来解析POST提交到服务器的表单数据</p>
<ol>
<li>定义中间件</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>) &#123;<br>  <span class="hljs-comment">// 中间件的业务逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>监听req的data事件<br>获取客户端发送给服务器的数据<br>若数据量较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以data事件可能会触发多次，每一次触发data事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义变量，用来存储客户端发送过来的请求体数据</span><br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment">// 监听req对象的data事件（客户端发送过来的请求体数据）</span><br>req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 拼接请求体数据，隐式转换为字符串</span><br>  str+=chunk<br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>监听req的end事件<br>当请求体接收数据完毕会自动触发req的end事件，因此可以在这里拿到完整的请求体数据</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 监听req对象的end事件 (请求体接收完毕后自动触发)</span><br>req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 打印完整的请求体数据</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)<br>  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> 把字符串格式的请求体数据解析成对象格式</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>使用querystring模块解析请求体数据<br>node.js内置了一个querystring模块，专门用来处理查询字符串。通过这个模块提供的parse()函数，可以轻松把查询字符串，解析成对象的格式</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入处理querystring的node.js模块</span><br><span class="hljs-keyword">const</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><br><span class="hljs-comment">// 调用qs.parse(),把查询字符串解析为对象格式</span><br><span class="hljs-keyword">const</span> body = qs.<span class="hljs-title function_">parse</span>(str)<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>将解析出来的数据对象挂载为req.body<br>上游下游中间件及路由之间共享一份req和res，因此我们可以解析出来的数据，挂载为req的自定义属性，命名为req.body</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;end&#x27;</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> body = qs.<span class="hljs-title function_">parse</span>(str)<br>  req.<span class="hljs-property">body</span> = body <span class="hljs-comment">// 将解析出来的请求体对象，挂载为req.body 属性</span><br>  <span class="hljs-title function_">next</span>() <span class="hljs-comment">// 最后，一定要调用next，执行后续的业务逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="6">
<li>将自定义中间件封装为模块</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// xx.js</span><br><span class="hljs-keyword">const</span> qs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bodyParser</span>(<span class="hljs-params">req,res,next</span>)&#123;&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = bodyParser<br><span class="hljs-comment">// ---------------------分割线---------------------</span><br><br><span class="hljs-comment">// 在另一个地方导入</span><br><span class="hljs-comment">// 导入自定义的中间件模块</span><br><span class="hljs-keyword">const</span> myBodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;custom-body-parse&#x27;</span>)<br><span class="hljs-comment">// 注册自定义的中间件模块</span><br>app.<span class="hljs-title function_">use</span>(myBodyParser)<br></code></pre></td></tr></table></figure>

<h2 id="使用express写接口"><a href="#使用express写接口" class="headerlink" title="使用express写接口"></a>使用express写接口</h2><ol>
<li>创建基本的服务器</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Express server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>创建API路由模块</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> apiRouter = express.<span class="hljs-title class_">Router</span>()<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = apiRouter<br><br><span class="hljs-comment">// ---------------------分割线---------------------</span><br><span class="hljs-comment">// app.js导入并注册路由模块</span><br><span class="hljs-keyword">const</span> apiRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./apiRouter.js&#x27;</span>)<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>,apiRouter)<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>编写GET接口</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">apiRouter.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/get&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取到客户端通过查询字符串,发送服务器的数据</span><br>  <span class="hljs-keyword">const</span> query = req.<span class="hljs-property">query</span><br>  <span class="hljs-comment">// 调用res.send() 方法，把数据响应给客户端</span><br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>,  <span class="hljs-comment">// 状态 0表示成功 1表示失败</span><br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;GET请求成功&#x27;</span>,  <span class="hljs-comment">//状态描述</span><br>    <span class="hljs-attr">data</span>: query   <span class="hljs-comment">// 需要响应给客户端的具体数据</span><br>  &#125;)<br><br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>编写POST接口</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">apiRouter.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/post&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 获取到客户端通过请求体,发送服务器的URL-encoded数据</span><br>  <span class="hljs-keyword">const</span> body = req.<span class="hljs-property">body</span><br>  <span class="hljs-comment">// 调用res.send() 方法，把数据响应给客户端</span><br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>,  <span class="hljs-comment">// 状态 0表示成功 1表示失败</span><br>    <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;POST请求成功&#x27;</span>,  <span class="hljs-comment">//状态描述</span><br>    <span class="hljs-attr">data</span>: body   <span class="hljs-comment">// 需要响应给客户端的具体数据</span><br>  &#125;)<br>&#125;)<br><span class="hljs-comment">// 如果要获取URL-encoded格式的请求体数据，必须配置中间件app.use(express.urlencoded(&#123;extended:false&#125;))</span><br></code></pre></td></tr></table></figure>

<ol start="5">
<li>接口的跨域问题<br>GET和POST接口均不支持跨域</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// GET 测试</span><br>$(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  $(<span class="hljs-string">&#x27;#btnGET&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    $.<span class="hljs-title function_">ajax</span>(&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;GET&#x27;</span>,<br>      <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://127.0.0.1/api/get&#x27;</span>,<br>      <span class="hljs-attr">data</span>:&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zs&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">20</span>&#125;,<br>      <span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>      &#125;<br>    &#125;)<br>  &#125;)<br><span class="hljs-comment">// POST 测试</span><br>  $(<span class="hljs-string">&#x27;#btnPOST&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    $.<span class="hljs-title function_">ajax</span>(&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;POST&#x27;</span>,<br>      <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://127.0.0.1/api/get&#x27;</span>,<br>      <span class="hljs-attr">data</span>:&#123;<span class="hljs-attr">boolName</span>:<span class="hljs-string">&#x27;活着&#x27;</span>,<span class="hljs-attr">author</span>:<span class="hljs-string">&#x27;余华&#x27;</span>&#125;,<br>      <span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>      &#125;<br>    &#125;)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>
<ul>
<li>协议域名端口号任何一项不一致都会造成跨域问题<br>【解决跨域问题】</li>
<li>CORS </li>
<li>JSONP 只支持GET请求</li>
</ul>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><ol>
<li>cors是express的一个第三方中间件，通过安装和配置cors中间件，可以很方便的解决跨域问题</li>
</ol>
<ul>
<li>npm i cors 安装中间件</li>
<li>const cors = require(‘cors’) 导入中间件</li>
<li>在路由之前调用 app.use(cors()) 配置中间件</li>
</ul>
<ol start="2">
<li>cors由一系列HTTP响应头组成，这些http响应头决定是否阻止前端JS代码跨域获取资源<br>[!浏览器的同源策略默认会阻止网页”跨域”获取资源，但如果接口服务器配置了CORS相关的HTTP响应头，就可以解除浏览器端的跨域访问限制]</li>
<li>在服务器端进行配置，客户端无需做额外配置</li>
<li>cors在浏览器中有兼容问性，只有支持XMLHttpRequest Level2的浏览器，才能正常访问开启了COE服务端接口(例如：IE10+,Chrome4+,FireFox3.5+)</li>
<li>cors响应头部 Access-Control-Allow-Origin<br>响应头部可以携带一个Access-Control-Allow-Origin字段，语法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>: &lt;origin&gt; | *<br></code></pre></td></tr></table></figure>
<ul>
<li>origin参数的值指定了允许访问该资源的外域URL<br>res.setHeader(‘Access-Control-Allow-Origin’,’<a target="_blank" rel="noopener" href="http://itcast.cn&/#39;">http://itcast.cn&#39;</a>)<br>上面的字段值将只允许来自<a target="_blank" rel="noopener" href="http://itcast.cn的请求/">http://itcast.cn的请求</a></li>
<li><ul>
<li>表示通配符，表示允许来自任何域的请求</li>
</ul>
</li>
</ul>
<ol start="6">
<li>CORS仅支持客户端向服务器发送的如下的9个请求头<br>Accept Accept-Language Content-Language DPR Downlink Save-Data Viewport-Width Width Content-Type(值仅限于text/plain、multipart/form-data、application/x-www-form-urlencoded三者之一)</li>
</ol>
<ul>
<li>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 注意多个请求头之间使用英文的逗号进行分割</span><br>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="hljs-string">&#x27;Content-Type,X-Custom-Header&#x27;</span>)<br></code></pre></td></tr></table></figure>

<ol start="7">
<li>Access-Control-Allow-Methods<br>默认情况下，CORS仅支持客户端发起GET、POST、HEAD请求<br>如果客户端希望通过PUT、DELETE等方式请求服务器的资源，则需要在服务器端，通过Access-Control-Allow-Methods来指明实际请求所允许使用的HTTP方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 只允许 GET、POST、HEAD、DELETE 请求方法</span><br>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>,<span class="hljs-string">&#x27;GET、POST、HEAD、DELETE&#x27;</span>)<br><span class="hljs-comment">// 允许所有的HTTP请求方法</span><br>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure>

<ol start="8">
<li>cors请求分类<br>根据请求方式和请求头的不同，将cors分为两大类</li>
</ol>
<ul>
<li>简单请求<br>满足这两个条件<ul>
<li>请求方式:GET POST HEAD 三者之一</li>
<li>HTTP头部信息不超过以下几种字段Accept Accept-Language Content-Language DPR Downlink Save-Data Viewport-Width Width Content-Type(值仅限于text/plain、multipart/form-data、application/x-www-form-urlencoded三者之一)</li>
</ul>
</li>
<li>预检请求<br>不满足简单请求的就是预检请求<ul>
<li>请求方式为GET POST HEAD 三者之外的Method类型</li>
<li>请求头中包含自定义头部字段</li>
<li>向服务器发送了application/json 格式的数据<br>在浏览器与服务器正式通信之间，浏览器会先发送OPTION请求进行预检，以获知服务器是否允许该实际请求，所以这一次的OPTION请求称为”预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</li>
</ul>
</li>
<li>简单请求与预检请求区别<ul>
<li>简单请求：客户端与服务器之间只会发生一次请求</li>
<li>预检请求：客户端与服务器之间会发生两次请求，OPTION预检请求成功之后，才会发起真正的请求</li>
</ul>
</li>
</ul>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>浏览器通过script标签的src属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做JSONP<br>特点：</p>
<ul>
<li>JSONP不属于真正的AJAX请求，因为它没有使用XMLHttpRequest这个对象</li>
<li>JSONP仅支持GET请求</li>
</ul>
<ol>
<li>注意事项<br>如果项目中配置了CORS跨域资源共享，为了防止冲突，必须在配置CORS中间件之前声明JSONP的接口。否则JSONP接口会被处理成开启了CORS的接口</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 优先创建 JSONP 接口【这个接口不会被处理成CORS接口】</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/jsonp&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;&#125;)<br><span class="hljs-comment">// 在配置CORS中间件【后续的所有接口都会被处理成CORS接口】</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>())<br><span class="hljs-comment">// 这是一个开启了CORS的接口</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/get&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>实现JSONP接口的步骤</li>
</ol>
<ul>
<li>获取客户端发送过来的回调函数的名字</li>
<li>得到要通过JSONP形式发送给客户端的数据</li>
<li>根据前两步得到的数据，拼接出一个函数调用的字符串</li>
<li>把上一步拼接得到的字符串，响应给客户端的script标签进行解析执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/jsonp&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 1. 获取客户端发送过来的回调函数的名字</span><br>  <span class="hljs-keyword">const</span> funcName = req.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span><br>  <span class="hljs-comment">// 2. 得到要通过JSONP形式发送给客户端的数据</span><br>  <span class="hljs-keyword">const</span> data = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zs&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">22</span>&#125;<br>  <span class="hljs-comment">// 3. 根据前两步得到的数据，拼接出一个函数调用的字符串</span><br>  <span class="hljs-keyword">const</span> scriptStr = <span class="hljs-string">`<span class="hljs-subst">$&#123;funcName&#125;</span>(<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(data)&#125;</span>)`</span><br>  <span class="hljs-comment">// 4. 把上一步拼接得到的字符串，响应给客户端的script标签进行解析执行</span><br>  res.<span class="hljs-title function_">send</span>(scriptStr)<br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>在网页中使用jquery发起jsonp请求<br>调用$.ajax函数，提供JSONP的配置选项，从而发起JSONP请求<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#btnJSONP&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  $.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;GET&#x27;</span>,<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://127.0.0.1/api/jsonp&#x27;</span>,<br>    <span class="hljs-attr">dataType</span>:<span class="hljs-string">&#x27;jsonp&#x27;</span>, <span class="hljs-comment">//表示要发起jsonp请求</span><br>    <span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>    &#125;<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="express中使用session认证"><a href="#express中使用session认证" class="headerlink" title="express中使用session认证"></a>express中使用session认证</h2><ol>
<li>安装中间件 npm i express-session</li>
<li>配置express-seesion中间件<br>通过app.use()来注册session中间件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-session&#x27;</span>)<br><span class="hljs-comment">// 配置session中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">session</span>(&#123;<br>  <span class="hljs-attr">secret</span>:<span class="hljs-string">&#x27;keyboard cat&#x27;</span>, <span class="hljs-comment">// secret属性值可以为任意字符串</span><br>  <span class="hljs-attr">resave</span>:<span class="hljs-literal">false</span>, <span class="hljs-comment">// 固定写法</span><br>  <span class="hljs-attr">saveUninitialized</span>:<span class="hljs-literal">true</span> <span class="hljs-comment">// 固定写法</span><br>&#125;))<br></code></pre></td></tr></table></figure></li>
<li>向session中存数据<br>当express-session中间件配置成功后，即可通过req.session来访问和使用session对象，从而存储用户的关键信息</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/login&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 判断用户提交的登陆信息是否正确</span><br>  <span class="hljs-keyword">if</span>(req.<span class="hljs-property">body</span>.<span class="hljs-property">username</span> !== <span class="hljs-string">&#x27;admin&#x27;</span> || req.<span class="hljs-property">body</span>.<span class="hljs-property">password</span> !== <span class="hljs-string">&#x27;000000&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;登录失败&#x27;</span>&#125;)<br>  &#125;<br>  req.<span class="hljs-property">session</span>.<span class="hljs-property">user</span> = req.<span class="hljs-property">body</span> <span class="hljs-comment">// 将用户的信息，存储到session中</span><br>  req.<span class="hljs-property">session</span>.<span class="hljs-property">islogin</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// 将用户的登录状态，存储到session中</span><br>  res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;登录成功&#x27;</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="4">
<li><p>从session中取数据<br>可以直接从req.session对象上获取之前的存储数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/username&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 判断用户是否登录</span><br>  <span class="hljs-keyword">if</span>(!req.<span class="hljs-property">session</span>.<span class="hljs-property">islogin</span>)&#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;fail&#x27;</span>&#125;)<br>  &#125;<br>  req.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;success&#x27;</span>,<span class="hljs-attr">username</span>:req.<span class="hljs-property">session</span>.<span class="hljs-property">user</span>.<span class="hljs-property">username</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li>
<li><p>清空session<br>比如退出登录，需要清空session<br>调用req.session.destroy()函数，即可清空服务器保存的信息</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 退出登录的接口</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/logout&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 清空当前客户端对应的session信息</span><br>  req.<span class="hljs-property">session</span>.<span class="hljs-title function_">destroy</span>()<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>:<span class="hljs-number">0</span>,<br>    <span class="hljs-attr">msg</span>:<span class="hljs-string">&#x27;退出登录成功&#x27;</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="express中使用JWT"><a href="#express中使用JWT" class="headerlink" title="express中使用JWT"></a>express中使用JWT</h2><ol>
<li>安装JWT相关包<br>npm i jsonwebtoken <a href="mailto:&#101;&#120;&#x70;&#x72;&#101;&#115;&#115;&#45;&#106;&#x77;&#x74;&#64;&#x35;&#x2e;&#x33;&#x2e;&#51;">&#101;&#120;&#x70;&#x72;&#101;&#115;&#115;&#45;&#106;&#x77;&#x74;&#64;&#x35;&#x2e;&#x33;&#x2e;&#51;</a></li>
</ol>
<ul>
<li>jsonwebtoken用于生成JWT字符串</li>
<li>express-jwt 用于将JWT字符串解析还原成JSON对象</li>
</ul>
<ol start="2">
<li>导入JWT相关的包</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>) <span class="hljs-comment">// 导入用于生成JWT字符串的包</span><br><span class="hljs-keyword">const</span> expressJWT = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>) <span class="hljs-comment">// 导入用于将客户端JWT字符串解析还原成JSON对象的包</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>定义secret密钥<br>为了保证jwt安全性，防止jwt字符串在网络传输过程中被别人破解，定义一个用于加密和解密的secret密钥</li>
</ol>
<ul>
<li>当生成JWT字符串的时候，需要使用secret密钥对用户的信息进行加密，最终得到加密好的jwt字符串</li>
<li>当把JWT字符串解析还原成JSON对象的时候，需要使用secret密钥进行解密<br>const secretKey = ‘itheima No1’ 越复杂与好</li>
</ul>
<ol start="4">
<li>在登录成功后生成JWT字符串<br>调用jsonwebtoken包提供的sign()方法，将用户的信息加密生成jwt字符串，响应给客户端</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 登录接口</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/login&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>) &#123;<br>    <span class="hljs-comment">// ...省略登录失败的代码</span><br>    <span class="hljs-comment">// 用户成功登陆后，生成JWT字符串，通过token属性响应给客户端</span><br>    res.<span class="hljs-title function_">send</span>(&#123;<br>      <span class="hljs-attr">status</span>:<span class="hljs-number">200</span>,<br>      <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;登录成功&#x27;</span>,<br>      <span class="hljs-comment">// 调用jwt提供的sign()方法，生成jwt字符串，三个参数分别是：用户信息对象，加密钥匙，配置对象(可以配置当前token的有效期)</span><br>      <span class="hljs-attr">token</span>: jwt.<span class="hljs-title function_">sign</span>(&#123;<span class="hljs-attr">username</span>:userInfo.<span class="hljs-property">username</span>&#125;,secretKey,&#123;<span class="hljs-attr">expiresIn</span>:<span class="hljs-string">&#x27;30s&#x27;</span>&#125;)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="5">
<li><p>将JWT字符串还原为JSON对象<br>客户端每次在访问那些有权限接口的时候，都需要主动通过请求头中的Authorization字段，将token字符串发送到服务器进行身份认证<br>此时，服务器可以通过express-jwt这个中间件，自动将客户端发送过来的token解析还原成JSON对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用app.use()来注册中间件</span><br><span class="hljs-comment">// expressJWT(&#123;secret:secretKey&#125;) 就是用来解析token的中间件</span><br><span class="hljs-comment">// .unless(&#123;path:[/^\/api\//]&#125;) 用来指定那些接口不需要访问权限</span><br><span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">expressjwt</span>:expressjwt&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>) <br><span class="hljs-comment">// 新版本</span><br><span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">expressjwt</span>:expressJWT&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>) <br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">expressJWT</span>(&#123;<span class="hljs-attr">secret</span>:secretKey&#125;).<span class="hljs-title function_">unless</span>(&#123;<span class="hljs-attr">path</span>:[<span class="hljs-regexp">/^\/api\//</span>]&#125;))<br><span class="hljs-comment">// unless若不能使用，可以在expressJWT中新加一个</span><br><span class="hljs-attr">algorithms</span>:[<span class="hljs-string">&#x27;HS256&#x27;</span>]<br></code></pre></td></tr></table></figure></li>
<li><p>使用req.user获取用户信息<br>当express-jwt这个中间件配置成功之后，即可在那些有权限的接口中，使用req.user对象，来访问从jwt字符串中解析出来的用户信息</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这是一个有权限的API接口</span><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/admin/getInfo&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>) &#123;<br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>:<span class="hljs-number">200</span>,<br>    <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;获取用户信息成功&#x27;</span>,<br>    <span class="hljs-attr">data</span>:req.<span class="hljs-property">user</span> <span class="hljs-comment">// 新版本或者比较高的版本用req.auth</span><br>    <span class="hljs-comment">// 若报空 那就 const authheader = req.headers[&quot;authorization&quot;]或者 const token = authheader &amp;&amp; authheader.split(&quot;&quot;)[1]</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="7">
<li>捕获解析JWT失败后产生的错误<br>当使用express-jwt解析token字符串时，如果用户发过来的token字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行。我们可以通过express的错误中间件，捕获这个错误并进行相关处理</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err,req,res,next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// token解析失败导致的错误</span><br>  <span class="hljs-keyword">if</span>(err.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;UnauthorizedError&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">401</span>,<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;无效的token&#x27;</span>&#125;)<br>  &#125;<br>  <span class="hljs-comment">// 其他原因导致的错误</span><br>  res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">500</span>,<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;未知错误&#x27;</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 优化后</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">err,req,res,next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 验证失败导致的错误</span><br>  <span class="hljs-keyword">if</span>(err <span class="hljs-keyword">instanceof</span> joi.<span class="hljs-property">ValidationError</span>) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">cc</span>(err)<br>  <span class="hljs-comment">// 身份认证失败后的错误</span><br>  <span class="hljs-keyword">if</span>(err.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;UnauthorizedError&#x27;</span>) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">cc</span>(<span class="hljs-string">&#x27;身份认证失败&#x27;</span>)<br>  <span class="hljs-comment">// 未知的错误</span><br>  res.<span class="hljs-title function_">cc</span>(err)<br>&#125;)<br></code></pre></td></tr></table></figure><div id="paginator"></div></div><div id="post-footer"></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">John Doe</a></h1><div id="description"><p>支持大家讨论交流</p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#express"><span class="toc-number">1.</span> <span class="toc-text">express</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http%E4%B8%8Eexpress%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.</span> <span class="toc-text">http与express对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#express-%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">express 做什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#express%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">express基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96URL%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">获取URL中的动态参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="toc-number">1.4.</span> <span class="toc-text">托管静态资源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#express%E8%B7%AF%E7%94%B1"><span class="toc-number">2.</span> <span class="toc-text">express路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%9D%97"><span class="toc-number">2.1.</span> <span class="toc-text">注册路由模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#express%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">express中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#next%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">next函数的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%94%9F%E6%95%88%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">全局生效的中间件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">中间件的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%85%A8%E5%B1%80%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">3.4.</span> <span class="toc-text">定义多个全局中间件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%B1%80%E9%83%A8%E7%94%9F%E6%95%88%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">3.5.</span> <span class="toc-text">定义局部生效的中间件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.6.</span> <span class="toc-text">中间件的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">3.7.</span> <span class="toc-text">自定义中间件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8express%E5%86%99%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.</span> <span class="toc-text">使用express写接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS"><span class="toc-number">4.1.</span> <span class="toc-text">CORS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSONP"><span class="toc-number">4.2.</span> <span class="toc-text">JSONP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#express%E4%B8%AD%E4%BD%BF%E7%94%A8session%E8%AE%A4%E8%AF%81"><span class="toc-number">5.</span> <span class="toc-text">express中使用session认证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#express%E4%B8%AD%E4%BD%BF%E7%94%A8JWT"><span class="toc-number">6.</span> <span class="toc-text">express中使用JWT</span></a></li></ol></div><section id="total"><a id="total-archives" href="/archives"><span class="total-title">文章 总数:</span><span class="total-number">5</span></a><div id="total-tags"><span class="total-title">标签:</span><span class="total-number">1</span></div><div id="total-categories"><span class="total-title">分类:</span><span class="total-number">5</span></div></section></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {code.findCode();
document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>