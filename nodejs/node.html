<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>nodejs | ALin的个人博客</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ALin的个人博客" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>nodejs</h1></div><hr><div id="post-content"><p>Node 的特点<br>  ○  事件驱动<br>  ○  非阻塞 IO（异步） 模型<br>  ○  单线程<br>  ○  跨平台<br>Node 的运行机制<br>多线程处理机制：<br class='item-img' data-src='/public/node_operationg.png'><img src="/public/node_operationg.png" alt="alt"><br>传统的 Web 服务器（Apache、Tomcat、IIS）：<br>  ○  请求进来<br>  ○  Web 服务器开启一个线程来处理用户请求<br>  ○  同一时间有 n 请求，服务器就需要开启 n 个线程<br>  ○<br>    ■ 一个线程最少得消耗 8MB 内存<br>  ○<br>    ■ 对于一个 8GB 内存的服务器来说，它能应对的并发数是 1024 * 8 / 8 = 1024 个并发</p>
<h2 id="node实现登录"><a href="#node实现登录" class="headerlink" title="node实现登录"></a>node实现登录</h2><p>引入jsonwebtoken生成令牌</p>
<ul>
<li>令牌组成<br>标头（Header）<br>有效负荷（Payload）<br>签名（Signature）<br>因此JWT通常为：xxxx.yyyy.zzzz，即Header.Payload.Signature</li>
</ul>
<h2 id="为什么JavaScript可以操作DOM和BOM？"><a href="#为什么JavaScript可以操作DOM和BOM？" class="headerlink" title="为什么JavaScript可以操作DOM和BOM？"></a>为什么JavaScript可以操作DOM和BOM？</h2><p class='item-img' data-src='/public/nodebom.png'><img src="/public/nodebom.png" alt="alt"><br>每个浏览器都内置了DOM、BOM这样的API函数，因此，浏览器中的JavaScript才可以调用他们</p>
<h2 id="什么是nodejs"><a href="#什么是nodejs" class="headerlink" title="什么是nodejs"></a>什么是nodejs</h2><p>node.js是一个基于v8引擎的JavaScript运行环境</p>
<ul>
<li>浏览器是JavaScript前端运行环境</li>
<li>node.js是JavaScript后端运行环境</li>
<li>node.js中无法调用DOM和BOM等浏览器内置的API<br>基于express框架，快速构建Web应用<br>基于electron框架，可以构建平台的桌面应用<br>基于restify框架，可以快速构建API接口项目</li>
</ul>
<h2 id="nodejs环境的安装"><a href="#nodejs环境的安装" class="headerlink" title="nodejs环境的安装"></a>nodejs环境的安装</h2><ol>
<li>区分LTS版本和Current版本的不同<br>LTS为长期稳定版，对于追求稳定性的企业来说，推荐安装LTS版本的node.js<br>Current为新特性尝鲜版</li>
</ol>
<ul>
<li>用powershell打开比cmd更好一些</li>
<li>esc键，快速清空当前已输入的命令</li>
<li>输入cls,可以清空终端</li>
</ul>
<h2 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h2><p>fs模块是node.js官方提供的、用来操作文件的模块。它提供了一系列属性和方法，满足用户对文件的操作需求</p>
<ul>
<li>fs.readFile() 用来读取指定文件中的内容</li>
<li>fs.writeFile() 用来向指定文件写入内容</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入fs模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br>fs.<span class="hljs-title function_">readFile</span>(path[,options],callback) <span class="hljs-comment">// 只有被中括号包着的options是可选参数</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 参数1 表示路径</span><br><span class="hljs-comment"> * 参数2 表示以什么编码格式来读取文件</span><br><span class="hljs-comment"> * 文件读取完成后，通过回调函数拿到读取的结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 例如：以utf8的编码格式，读取指定文件内容，并打印err和dataStr的值</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./file/1.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,dataStr</span>)&#123;<br>  <span class="hljs-comment">// 打印失败的结果</span><br>  <span class="hljs-comment">// 如果读取成功则，err结果为null</span><br>  <span class="hljs-comment">// 如果读取失败，err值为错误对象，dataStr值为undefined</span><br>  <span class="hljs-keyword">if</span>(err) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;读取文件失败&#x27;</span>+err.<span class="hljs-property">message</span>)<br>  &#125;<br>  <br>  <span class="hljs-comment">// 打印成功的结果</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dataStr)<br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.<span class="hljs-title function_">writeFile</span>(file,data[,options],callback)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 参数1:必选参数，需要指定的一个文件路径的字符串，表示文件的存放路径</span><br><span class="hljs-comment"> * 参数2:必选参数，表示要写入的内容</span><br><span class="hljs-comment"> * 参数3：可选参数，表示以什么格式写入文件，默认是utf8</span><br><span class="hljs-comment"> * 参数4:必选参数：文件写入完成后的回调函数</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// 如果文件写入成功则，err结果为null</span><br><span class="hljs-comment">// 如果文件写入失败，err值为错误对象，dataStr值为undefined</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;./file/2.txt&#x27;</span>,<span class="hljs-string">&#x27;hello node.js&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;<br>  <span class="hljs-keyword">if</span>(err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err)<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;文件写入成功&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li>Windows中\r\n表示换行</li>
</ul>
<h3 id="fs的路径拼接问题"><a href="#fs的路径拼接问题" class="headerlink" title="fs的路径拼接问题"></a>fs的路径拼接问题</h3><p>如果提供的操作路径是以./或../开头的相对路径，很容易出现路径动态拼接错误问题<br>原因：代码在运行的时候，会以执行node命令时所处的目录，动态拼接出被操作文件的完整路径<br>解决方案：在使用fs操作文件时，直接提供完整的路径，不要提供./或../开头的相对路径，从而防止路径动态拼接的问题<br>__dirname表示当前文件所处的目录<br>fs.readFile(__dirname+ ‘/file/1.txt’,’utf8’,function() {}) 文件路径可以写成这种形式</p>
<ul>
<li>path.join() 将多个路径片段拼成一个完整的路径字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pathStr = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;/b/c&#x27;</span>,<span class="hljs-string">&#x27;../&#x27;</span>,<span class="hljs-string">&#x27;./d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pathStr) <span class="hljs-comment">// \a\b\d\e</span><br><span class="hljs-keyword">const</span> pathStr = path.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;/b/c&#x27;</span>,<span class="hljs-string">&#x27;../../&#x27;</span>,<span class="hljs-string">&#x27;./d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pathStr) <span class="hljs-comment">// \a\d\e</span><br><span class="hljs-comment">// ../../会抵消前面两层路径</span><br>fs.<span class="hljs-title function_">writeFile</span>(__dirname,<span class="hljs-string">&#x27;./file/2.txt&#x27;</span>,<span class="hljs-string">&#x27;hello node.js&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123; <br>  <span class="hljs-comment">// 如果是这样路径拼接会报错，因为前面有.</span><br>&#125;)<br>fs.<span class="hljs-title function_">writeFile</span>(path.<span class="hljs-title function_">join</span>(__dirname,<span class="hljs-string">&#x27;./file/2.txt&#x27;</span>),<span class="hljs-string">&#x27;hello node.js&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123; <br>  <span class="hljs-comment">// 如果是这样路径拼接会报错，因为前面有.</span><br>&#125;)<br></code></pre></td></tr></table></figure>
<ul>
<li>path.basename() 从路径字符串中，将文件名解析出来</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span> <span class="hljs-comment">// 文件的存放路径</span><br><span class="hljs-keyword">var</span> fullName = path.<span class="hljs-title function_">basename</span>(fpath)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullName) <span class="hljs-comment">// 输出index.html</span><br><span class="hljs-keyword">var</span> name = path.<span class="hljs-title function_">basename</span>(fpath,<span class="hljs-string">&#x27;.html&#x27;</span>) <span class="hljs-comment">// 第二个参数是去除文件扩展名</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name) <span class="hljs-comment">// index</span><br></code></pre></td></tr></table></figure>

<ul>
<li>path.extname() 获取路径中扩展名部分<br>path.extname(path)<br>参数解读:<br>path string 标签必选参数，表示一个路径的字符串<br>返回string标签返回得到的扩展名字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fpath = <span class="hljs-string">&#x27;/a/b/c/index.html&#x27;</span> <span class="hljs-comment">// 文件的存放路径</span><br><span class="hljs-keyword">var</span> fullName = path.<span class="hljs-title function_">extname</span>(fpath)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fullName) <span class="hljs-comment">// .html</span><br></code></pre></td></tr></table></figure>

<ul>
<li>fs.readFile() 只能创建文件不能创建路径</li>
<li>重复调用fs.writeFile() 写入同一个文件，新写入的内容会覆盖之前的旧内容</li>
</ul>
<h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><ul>
<li>什么是客户端，什么是服务器？<br>在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器</li>
<li>什么是http模块？<br>http模块是nodejs官方提供的，用来创建web服务器的模块。通过http模块提供的http.createServer() 方法，就能方便的把一台普通的电脑变成一台web服务器，从而对外提供web资源服务</li>
<li>使用<br>const http = require(‘http’)</li>
<li>服务器和普通电脑的区别在于，服务器上安装了web服务器软件，例如：IIS、Apache等。通过安装服务器软件，就能把一台普通的电脑变成一台web服务器<br>node.js是不需要使用IIS、Apache等这些第三方web服务器软件。因为我们可以基于node.js提供的http模块，通过几行简单的代码，就能轻松的手写一个服务器软件，从而对外提供web服务</li>
</ul>
<h2 id="服务器相关概念"><a href="#服务器相关概念" class="headerlink" title="服务器相关概念"></a>服务器相关概念</h2><ol>
<li>IP地址</li>
</ol>
<ul>
<li>IP地址就是互联网上每台计算机的唯一地址，因此IP地址具有唯一性。只有在知道IP地址的前提下，才能与对应的电脑之间进行数据通信<br>IP地址的格式：通常用“点分十进制”表示成(a.b.c.d)的形式，其中a,b,c,d都是0-255之间的十进制整数。例如IP地址(192.168.1.1)</li>
<li>互联网中每台web服务器，都有自己的IP地址<br>例如可以在window的终端中运行ping <a target="_blank" rel="noopener" href="http://www.baidu.com命令,即可查看到百度服务器的ip地址/">www.baidu.com命令，即可查看到百度服务器的IP地址</a></li>
<li>在开发期间，自己的电脑是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入127.0.0.1这个IP地址，就能把自己的电脑当作一台服务器进行访问了</li>
</ul>
<ol start="2">
<li>域名和域名服务器</li>
</ol>
<ul>
<li>尽管IP地址能够唯一地标记网络上的计算机，但IP地址是一长串数字，不直观，不便于记忆，于是人们又发明了另一套字符型的地址方案，即所谓的域名地址</li>
<li>IP和域名是一一对应的关系，这份对应关系存放在一种叫做域名服务器(DNS，Domain name server)的电脑中，多个域名可以指向同一个服务器，域名服务器就是提供IP地址和域名之间转换服务的服务器</li>
</ul>
<ul>
<li>单纯使用IP地址，互联网中的电脑也可以正常工作，但有域名加持，能让互联网的世界变得更加方便</li>
<li>127.0.0.1对应的域名是localhost，它们都代表我们这台电脑</li>
</ul>
<ol start="3">
<li>端口号<br>计算机中的端口号，就像生活中的门牌号，通过门牌号，外卖小哥可以在整栋大楼众多的房间中准确把外卖送到你的手中</li>
</ol>
<ul>
<li>在一台电脑中可以运行成百上千个web服务器。每个web服务都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的web服务进行处理</li>
</ul>
<ul>
<li>每个端口号不能同时被多个web服务占用</li>
</ul>
<h2 id="创建最基本的web服务器"><a href="#创建最基本的web服务器" class="headerlink" title="创建最基本的web服务器"></a>创建最基本的web服务器</h2><ol>
<li>导入http模块</li>
<li>创建web服务器实例</li>
<li>为服务器实例绑定request事件，监听客户端的请求</li>
<li>启动服务器</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 导入http模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-comment">// 2. 创建web服务器实例</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br><span class="hljs-comment">// 3. 使用服务器实例的.on()方法，为服务器绑定一个request事件</span><br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req.res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 只要有客户端来请求我们自己的服务器，就会触发request事件，从而调用这个事件处理函数</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Someone visit our web server&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// 4. 启动服务器</span><br><span class="hljs-comment">// 调用服务器实例的.listen()方法，即可启动当前的web服务器实例</span><br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 调用server.listen(端口号,cb回调)方法，即可启动web服务器</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;http server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="req请求对象、-响应对象"><a href="#req请求对象、-响应对象" class="headerlink" title="req请求对象、 响应对象"></a>req请求对象、 响应对象</h3><p>只要服务器接收到到了客户端的请求，就会调用通过server.on()为服务器绑定的request事件处理函数。如果想在事件处理函数中，访问与客户端相关的属性或数据，可以使用如下方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * req是请求对象，它包含了与客户端相关的数据和属性，例如: </span><br><span class="hljs-comment">    * req.url 是客户端请求的URL地址</span><br><span class="hljs-comment">    * req.method 是客户端的method请求类型</span><br><span class="hljs-comment">  */</span> <br> <span class="hljs-keyword">const</span> str = <span class="hljs-string">`Your Request url is <span class="hljs-subst">$&#123;req.url&#125;</span>,and request method is <span class="hljs-subst">$&#123;req.method&#125;</span>`</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * res 是响应对象，它包含了与服务器相关的数据和属性</span><br><span class="hljs-comment">  * res.end(str)</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-comment">// 调用res.end() 方法，向客户端响应一些内容</span><br> res.<span class="hljs-title function_">end</span>(str)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在server.on中设置响应头 setHeader</span><br>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>,<span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h2 id="根据不同的url响应不同的html内容"><a href="#根据不同的url响应不同的html内容" class="headerlink" title="根据不同的url响应不同的html内容"></a>根据不同的url响应不同的html内容</h2><ol>
<li>获取请求的url地址</li>
<li>设置默认的行为内容为404 Not Found</li>
<li>判断用户请求的是否为/或/index.html首页</li>
<li>判断用户请求是否为 /about.html关于页面</li>
<li>设置Content-Type响应头，防止中文乱码</li>
<li>使用res,end() 把内容响应给客户端</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>()<br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">res,req</span>) &#123;<br>  <span class="hljs-comment">// 1. 获取请求的url地址 </span><br>  <span class="hljs-keyword">const</span> url = req.<span class="hljs-property">url</span><br>  <span class="hljs-comment">// 2. 设置默认的响应内容为404 Not Found</span><br>  <span class="hljs-keyword">let</span> content = <span class="hljs-string">&#x27;404 Not Found&#x27;</span><br>  <span class="hljs-comment">// 3. 判断用户请求的是否为/或/index.html首页 </span><br>  <span class="hljs-keyword">if</span>(url === <span class="hljs-string">&#x27;/&#x27;</span> || url === <span class="hljs-string">&#x27;/index.html&#x27;</span>) &#123;<br>    content = <span class="hljs-string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span><br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(url === <span class="hljs-string">&#x27;/about.html&#x27;</span>) &#123;<br>    content = <span class="hljs-string">&#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span><br>  &#125;<br>  <span class="hljs-comment">// 5. 设置Content-Type响应头，防止中文乱码</span><br>  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>,<span class="hljs-string">&#x27;text/html; charset=utf-8&#x27;</span>)<br>  <span class="hljs-comment">// 6. 使用 res.end() 把内容响应给客户端</span><br>  res.<span class="hljs-title function_">end</span>(content)<br>&#125;)<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">80</span>,<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;server running at http://127.0.0.1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="时钟案例server中的应用"><a href="#时钟案例server中的应用" class="headerlink" title="时钟案例server中的应用"></a>时钟案例server中的应用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fpath = path.<span class="hljs-title function_">join</span>(__dirname,url)<br>fs.<span class="hljs-title function_">readFile</span>(fpath,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,dataStr</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 读取失败</span><br>  <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;404 Not Found&#x27;</span>)<br>  <span class="hljs-comment">// 读取成功</span><br>  res.<span class="hljs-title function_">end</span>(dataStr)<br>&#125;)<br><span class="hljs-comment">// 优化资源的请求路径</span><br><span class="hljs-keyword">let</span> fpath = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">if</span>(url === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>  <span class="hljs-comment">// 如果请求路径为 /，则手动指定文件的存放路径</span><br>  fpath = path.<span class="hljs-title function_">join</span>(__dirname,<span class="hljs-string">&#x27;./clock/index.html&#x27;</span>)<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 如果请求路径不为 &#x27;/&#x27; 则动态拼接文件的存放路径</span><br>  fpath = path.<span class="hljs-title function_">join</span>(__dirname,<span class="hljs-string">&#x27;./clock&#x27;</span>,url)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>请求头要判断，否则最好先不写</li>
</ul>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>模块化是指解决一个复杂问题时，自项向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块时可组合、分解和更换的单元</p>
<ul>
<li>遵守固定规则，把一个大文件拆成独立并互相依赖的多个小模块</li>
<li>好处：</li>
</ul>
<ol>
<li>提高代码复用性</li>
<li>提高代码可维护性</li>
<li>可以实现按需加载                 <h3 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h3>模块化规范就是对代码进行模块化拆分与组合时，需要遵守的那些规则<br>比如：<br>使用什么样的语法格式来引用模块<br>在模块中使用什么样的语法格式向外暴露成员</li>
</ol>
<h3 id="nodejs中的模块化"><a href="#nodejs中的模块化" class="headerlink" title="nodejs中的模块化"></a>nodejs中的模块化</h3><ol>
<li>分为三大类</li>
</ol>
<ul>
<li>内置模块<br>由node.js官方提供的，例如fs、path、http</li>
<li>自定义模块<br>用户创建的每个.js文件都是自定义模块</li>
<li>第三方模块<br>由第三方开发出来的模块，使用前需要先下载</li>
</ul>
<ol start="2">
<li>加载模块<br>使用require方法，加载上述三大类模块</li>
<li>什么是模块作用域<br>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</li>
</ol>
<ul>
<li>好处：防止全局变量污染</li>
</ul>
<h3 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h3><p>在每个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息</p>
<h4 id="module-exports-对象"><a href="#module-exports-对象" class="headerlink" title="module.exports 对象"></a>module.exports 对象</h4><p>module中有一个属性，module.exports 将模块内的成员共享出去，供外界使用<br>外界用require()方法导入自定义模块时，得到的就是module.export 所指向的对象</p>
<h4 id="向外共享模块作用域中的成员"><a href="#向外共享模块作用域中的成员" class="headerlink" title="向外共享模块作用域中的成员"></a>向外共享模块作用域中的成员</h4><p>注意：使用require() 方法导入模块时，导入的结果，永远以module.exports 指向的对象为准</p>
<h2 id="exports-对象"><a href="#exports-对象" class="headerlink" title="exports 对象"></a>exports 对象</h2><p>module.exports 写起来比较复杂，为了简化向外共享成员的代码，node提供了exports对象。默认情况下，exports和module.exports指向同一个对象。最终共享结果还是以module.exports指向的对象为准</p>
<h2 id="node-js遵循CommonJS模块化规范"><a href="#node-js遵循CommonJS模块化规范" class="headerlink" title="node.js遵循CommonJS模块化规范"></a>node.js遵循CommonJS模块化规范</h2><p>CommonJS规定了模块的特性和各个模块之间如何相互依赖<br>CommonJS规定：</p>
<ol>
<li>每个模块内部，module变量代表当前模块</li>
<li>module变量是一个对象，它的exports属性（即module.exports）是对外的接口</li>
<li>加载某个模块，其实是加载该模块的module.exports属性，require() 方法用于加载模块</li>
</ol>
<h2 id="下包的镜像源"><a href="#下包的镜像源" class="headerlink" title="下包的镜像源"></a>下包的镜像源</h2><ol>
<li>查看下包的镜像源，也就是下包的服务器地址<br>npm config get registry</li>
<li>将下包的镜像源切换为淘宝镜像源<br>npm config set registry=<a target="_blank" rel="noopener" href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org/</a></li>
<li>检查镜像源是否下载成功<br>npm config get registry</li>
</ol>
<h2 id="解决下包速度慢的问题"><a href="#解决下包速度慢的问题" class="headerlink" title="解决下包速度慢的问题"></a>解决下包速度慢的问题</h2><p>为了更方便的切换下包的镜像源，可以安装nrm<br>npm i nrm-g<br>nrm ls 查看所有可用的镜像源<br>nrm use taobao 将下包的镜像源切换为淘宝镜像源</p>
<h2 id="md转html"><a href="#md转html" class="headerlink" title="md转html"></a>md转html</h2><p>i5ting_toc<br>npm i -g i5ting_toc<br>调用i5ting_toc<br>i5ting_toc -f 要转换的md文件路径 -o</p>
<ul>
<li>package.json中必须包含name、version、main这三个属性，分别代表包的名字、版本号、包的入口</li>
</ul>
<h2 id="开发属于自己的包"><a href="#开发属于自己的包" class="headerlink" title="开发属于自己的包"></a>开发属于自己的包</h2><p>初始化包的基本结构</p>
<ol>
<li>新建itheima-tools 文件夹，作为包的根目录</li>
<li>在itheima-tools文件夹中，新建三个文件</li>
</ol>
<ul>
<li>package.json (包管理配置文件)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;itheima-tools&quot;</span>,<br>  <span class="hljs-string">&quot;version&quot;</span> : <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;main&quot;</span> : <span class="hljs-string">&quot;index.js&quot;</span>,<br>  <span class="hljs-string">&quot;description&quot;</span> : <span class="hljs-string">&quot;提供了格式化时间，HTMLEscape的功能&quot;</span>,<br>  <span class="hljs-string">&quot;keywords&quot;</span> : [<span class="hljs-string">&quot;itheima&quot;</span>,<span class="hljs-string">&quot;dateFormat&quot;</span>,<span class="hljs-string">&quot;escape&quot;</span>],<br>  <span class="hljs-string">&quot;license&quot;</span>:<span class="hljs-string">&quot;ISC&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>index.js (包的入口文件)</li>
<li>README.md (包的说明文档)</li>
</ul>
<ol start="3">
<li></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// test.js</span><br><span class="hljs-keyword">const</span> itheima = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./itheima-tools/index&#x27;</span>)<br><span class="hljs-comment">// 格式化时间的功能</span><br><span class="hljs-keyword">const</span> dtStr = itheima.<span class="hljs-title function_">dateFormat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>())<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dtStr)<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>在index.js中转义HTML的方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">HTMLEscape</span>(<span class="hljs-params">htmlStr</span>) &#123;<br>  <span class="hljs-keyword">return</span> htmlStr.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;|&gt;|&quot;|&amp;/g</span>,<span class="hljs-function">(<span class="hljs-params">match</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">switch</span>(match) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span> :<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&amp;lt;&#x27;</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span> :<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&amp;gt&#x27;</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&quot;&#x27;</span> :<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&amp;quot&#x27;</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&amp;&#x27;</span> :<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&amp;amp&#x27;</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义还原html字符串的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">HTMLUnEscape</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&amp;lt;|&amp;gt;|&amp;quot;|&amp;amp;/g</span>,<span class="hljs-function">(<span class="hljs-params">match</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">switch</span>(match) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&amp;lt&#x27;</span> :<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;&#x27;</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&amp;gt&#x27;</span> :<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&gt;&#x27;</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&amp;quot&#x27;</span> :<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&quot;&#x27;</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&amp;amp&#x27;</span> :<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&amp;&#x27;</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>将不同功能进行模块化拆分<br>将格式化时间的功能，拆分到src -&gt; dateFormat.js中<br>将处理HTML字符串的功能，拆分到src -&gt; htmlEscape.js中<br>在index.js中导入两个模块，得到需要向外共享的方法<br>在index.js中，使用module.exports 把对应的方法共享出去</li>
</ol>
<h2 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h2><p>模块在第一次加载后会被缓存。意味着多次调用require() 不会导致模块的代码被执行多次</p>
<ul>
<li>内置模块加载优先级最高</li>
<li>require 加载自定义模块时，必须指定以./或../开头的路径标识符，若没有会被当作内置模块或者第三方模块进行加载</li>
<li>第三方模块加载是前两者都没有，再尝试从/node_modules文件中加载第三方模块，如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录</li>
</ul>
<h2 id="web开发模式"><a href="#web开发模式" class="headerlink" title="web开发模式"></a>web开发模式</h2><p>目前主流是两种</p>
<ol>
<li>基于服务端渲染的传统web开发模式<br>服务器发送给客户端的HTML页面，是在服务器通过字符串拼接，动态生成的。因此，客户端不需要使用ajax这样的技术额外请求页面的数据</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/index.html&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 要渲染的数据</span><br>  <span class="hljs-keyword">const</span> user = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;zs&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">20</span>&#125;<br>  <span class="hljs-comment">// 服务器端通过字符串拼接，动态生成HTML内容</span><br>  <span class="hljs-keyword">const</span> html = <span class="hljs-string">`&lt;h1&gt;姓名:<span class="hljs-subst">$&#123;user.name&#125;</span>,年龄:<span class="hljs-subst">$&#123;user.age&#125;</span>&lt;/h1&gt;`</span><br>  <span class="hljs-comment">// 把生成好的页面内容响应给客户端，因此客户端拿到的是带有真实数据的HTML页面</span><br>  res.<span class="hljs-title function_">send</span>(html)<br>&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li>优点<ul>
<li>前端耗时少，因为服务器动态生成html内容，浏览器只需要直接渲染页面即可。尤其是移动端，更省电</li>
<li>有利于SEO 因为服务器端响应的是完整的html页面内容，所以爬虫更容易获得信息</li>
</ul>
</li>
<li>缺点<ul>
<li>占用服务器端资源，即服务器端完成HTML页面内容的拼接，如果请求多，会对服务器造成一定的访问压力</li>
<li>不利于前后端分离，开发效率低，使用服务器端渲染，则无法进行分工合作，尤其对于前端复杂度高的项目，不利于项目高效开发</li>
</ul>
</li>
</ul>
<ol start="2">
<li>基于前后端分离的新型web开发模式<br>依赖于ajax，后端只负责提供API接口，前端使用ajax调用接口的开发模式</li>
</ol>
<ul>
<li>优点<ul>
<li>开发体验好，前端专注于UI页面的开发，后端专注于api的开发，且前端有更多的选择性</li>
<li>用户体验好，ajax技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷新</li>
<li>减轻了服务器端的渲染压力，因为页面最终是在每个用户的浏览器中生成的</li>
</ul>
</li>
<li>缺点<ul>
<li>不利于SEO，因为完整的HTML页面需要在客户端动态拼接完成，所以爬虫无法爬取页面的有效信息(解决方法：利用Vue、React等前端框架的SSR技术能够很好的解决SEO问题)<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3>主要功能展示而没有复杂的交互，并且需要良好的SEO，需要用服务器端渲染<br>类似后台管理，交互性比较强，不需要考虑SEO，那么就是前后端分离的开发模式</li>
</ul>
</li>
<li>但这也并不是绝对，为了同时兼顾了首页的渲染速度和前后端分离的开发效率，一些网站采用了首屏服务器端渲染 + 其他页面前后端分离的开发模式</li>
</ul>
<h2 id="session认证机制"><a href="#session认证机制" class="headerlink" title="session认证机制"></a>session认证机制</h2><ol>
<li>HTTP协议的无状态性<br>指的是客户端的每次HTTP请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次HTTP请求的状态</li>
</ol>
<ul>
<li>如何突破HTTP无状态的限制<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3></li>
</ul>
<ol>
<li>存储在用户浏览器中的一段不超过4KB的字符串，它由一个名称（name）、一个值（value）和其他几个用于控制cookie有效期、安全性、使用范围的可选属性组成</li>
<li>不同域名下的cookie各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的cookie一同发送到服务器</li>
</ol>
<ul>
<li>cookie的几大特性<ul>
<li>自动发送</li>
<li>域名独立</li>
<li>过期时限</li>
<li>4KB限制</li>
</ul>
</li>
</ul>
<ol start="3">
<li>cookie在身份认证中的作用<br>客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的cookie，客户端会自动将cookie保存在浏览器中<br>随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份</li>
<li>cookie不具有安全性<br>由于cookie是存储在浏览器中的，而且浏览器也提供了读写cookie的API，因此cookie很容易被伪造，不具有安全性，因此不建议服务器将重要的隐私数据，通过cookie的形式发送给浏览器</li>
</ol>
<h3 id="session工作原理"><a href="#session工作原理" class="headerlink" title="session工作原理"></a>session工作原理</h3><p class='item-img' data-src='/public/session.png'><img src="/public/session.png" alt="alt"></p>
<h2 id="前后端的身份认证"><a href="#前后端的身份认证" class="headerlink" title="前后端的身份认证"></a>前后端的身份认证</h2><h3 id="express使用session"><a href="#express使用session" class="headerlink" title="express使用session"></a>express使用session</h3><p><a href="./express">去express找找吧</a></p>
<h3 id="jwt认证机制"><a href="#jwt认证机制" class="headerlink" title="jwt认证机制"></a>jwt认证机制</h3><ol>
<li>session局限性<br>session认证机制需要配合cookie才能实现，由于cookie默认不支持跨域访问，所以当涉及到前端跨域请求后端接口的时候，需要做很多额外配置，才能实现session认证</li>
</ol>
<ul>
<li>当前端请求后端接口不存在跨域问题的时候，推荐使用session身份认证机制</li>
<li>当前端需要跨域请求后端接口的时候，不推荐使用session身份认证机制，推荐使用jwt认证机制</li>
</ul>
<ol start="2">
<li>什么是jwt?<br>JSON Web Token 是目前最流行的跨域认证解决方案</li>
<li>jwt工作原理<br class='item-img' data-src='/public/jwt.png'><img src="/public/jwt.png" alt="alt"></li>
</ol>
<p>总结：将用户的信息通过token字符串形式，保存在客户端浏览器中。服务器通过还原token字符串的形式来认证用户的身份<br>4. jwt组成部分<br>三部分：</p>
<ul>
<li>Header(头部)</li>
<li>Payloa(有效荷载)</li>
<li>Signature(签名)<br>三者之间用英文的.来进行分割<br>Header.Payload.Signature</li>
<li>payload是真正的用户信息，它是用户信息经过加密后生成的字符串</li>
<li>Header(头部)和 Signature是安全相关的部分，只是为了保证token的安全性</li>
</ul>
<ol start="5">
<li>jwt使用方式<br>客户端收到服务器返回的jwt，通常会将它存储在localStorage和sessionStorage中<br>此后，客户端每次与服务器通信，都要带上这个JWT的字符串，从而进行身份认证。推荐做法是把JWT放在HTTP请求头的Authorization字段中<br>Authorization:Bearer <token></li>
<li>在express中使用jwt<br><a href="./express">去express找找吧</a></li>
</ol>
<h2 id="项目中对密码进行加密处理"><a href="#项目中对密码进行加密处理" class="headerlink" title="项目中对密码进行加密处理"></a>项目中对密码进行加密处理</h2><p>为了保证密码的安全性，不建议在数据库以明文的形式保存用户密码，推荐对密码进行加密存储<br>在当前项目中，使用bcryptjs，对用户密码进行加密</p>
<ul>
<li>优点<ul>
<li>加密之后对密码无法被逆向破解</li>
<li>同一明文密码多次加密，得到的加密结果各不相同，保证了安全性</li>
</ul>
</li>
<li>步骤</li>
</ul>
<ol>
<li>npm i <a href="mailto:&#98;&#99;&#x72;&#x79;&#112;&#116;&#106;&#115;&#x40;&#50;&#x2e;&#x34;&#46;&#x33;">&#98;&#99;&#x72;&#x79;&#112;&#116;&#106;&#115;&#x40;&#50;&#x2e;&#x34;&#46;&#x33;</a></li>
<li>在/router_handler/user.js中导入bcryptjs<br>const bcrypt = require(‘bcryptjs’)</li>
<li>在注册用户的处理函数中，确认用户名可用后调用bcrypt.hashSync(明文密码,随机延的长度)方法，对用户的密码进行加密处理</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对用户的密码，进行bcrypt加密，返回值是加密之后的密码字符串</span><br>userInfo.<span class="hljs-property">password</span> = bcrypt.<span class="hljs-title function_">hashSync</span>(userInfo.<span class="hljs-property">password</span>,<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure>

<h2 id="插入新用户"><a href="#插入新用户" class="headerlink" title="插入新用户"></a>插入新用户</h2><ol>
<li>定义插入用户的SQL语句<br>const sql = ‘insert into ev_users set ?’</li>
<li>调用db.query()，执行SQL语句，插入新用户<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 同上一个对密码进行加密处理，写在它的下面，都写在/router_handler/user.js中</span><br>db.<span class="hljs-title function_">query</span>(sql,&#123;<span class="hljs-attr">username</span>:userInfo.<span class="hljs-property">username</span>,<span class="hljs-attr">password</span>:userInfo.<span class="hljs-property">password</span>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,results</span>) &#123;<br>  <span class="hljs-comment">// 执行SQ语句L失败</span><br>  <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">message</span>:err.<span class="hljs-property">message</span>&#125;)<br>  <span class="hljs-comment">// SQL语句执行成功，但影响行数不为1</span><br>  <span class="hljs-keyword">if</span>(results.<span class="hljs-property">affextedRows</span> !==<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;注册用户失败，请稍后再试！&#x27;</span>&#125;)<br>  &#125;<br>  <span class="hljs-comment">// 注册成功</span><br>  res.<span class="hljs-title function_">send</span>(&#123;<span class="hljs-attr">status</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;注册成功&#x27;</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h2><ol>
<li>在处理函数过程中需要多次调用res.send()向客户端响应处理失败的结果，为了简化代码，可以手动封装一个res.cc函数</li>
</ol>
<ul>
<li>在app.js中，所有路由之前，声明一个全局中间件，为res对象挂载一个res.cc()函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 一定要在路由之前，封装res.cc函数</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res,next</span>) &#123;<br>  res.<span class="hljs-property">cc</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">err,status=<span class="hljs-number">1</span></span>) &#123;<br>    res.<span class="hljs-title function_">send</span>(&#123;<br>      <span class="hljs-comment">// 状态</span><br>      status,<br>      <span class="hljs-comment">// 状态描述，判断err是错误对象还是字符串</span><br>      <span class="hljs-attr">message</span>:err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span> ? err.<span class="hljs-property">message</span> : err<br>      <span class="hljs-comment">// Error是一个表示错误类型的构造函数，instanceof判断err是否是错误类型</span><br>      <span class="hljs-comment">// 查询语句的回调函数不要用箭头函数，用文档里的匿名函数，否则插入两次控制台会报错</span><br>    &#125;)<br>  &#125;<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>优化表单数据验证<br>表单验证原则，前端为辅，后端为主<br>单纯使用if…else的形式对数据进行合法验证效率低、易出错、维护性差，推荐使用第三方数据验证模块</li>
</ol>
<ul>
<li>npm i joi</li>
<li>npm @escook/express-joi<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Joi</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;joi&quot;</span>)<br><span class="hljs-keyword">const</span> expressJoi = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-joi&#x27;</span>)<br><span class="hljs-comment">// 解析x-www-form-urlencoded 格式的表单数据</span><br>app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">urlencoded</span>(&#123;<span class="hljs-attr">extended</span>:<span class="hljs-literal">false</span>&#125;))<br><br><span class="hljs-comment">// 定义验证规则</span><br><span class="hljs-keyword">const</span> userSchema = &#123;<br>  <span class="hljs-comment">// 校验req.body中的数据</span><br>  <span class="hljs-attr">body</span>:&#123;<br>    <span class="hljs-attr">username</span>:<span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">alphanum</span>().<span class="hljs-title function_">min</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">max</span>(<span class="hljs-number">12</span>).required(),<br>    <span class="hljs-attr">password</span>:<span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">pattern</span>(<span class="hljs-regexp">/^[\S]&#123;6,15&#125;$/</span>), <span class="hljs-comment">//pattern(正则表达式) 值必须符合正则表达式的规则</span><br>    <span class="hljs-attr">repassword</span>:<span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;password&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-comment">// 校验req.query中的数据</span><br>  <span class="hljs-attr">query</span>:&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">alphanum</span>().<span class="hljs-title function_">min</span>(<span class="hljs-number">3</span>).required(),<br>    <span class="hljs-attr">age</span>:<span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">number</span>().<span class="hljs-title function_">interger</span>().<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">max</span>(<span class="hljs-number">100</span>).required()<br>  &#125;,<br>  <span class="hljs-comment">// 校验req.params 中的数据</span><br>  <span class="hljs-attr">params</span>:&#123;<br>    <span class="hljs-attr">id</span>:<span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">number</span>().<span class="hljs-title function_">interger</span>().<span class="hljs-title function_">min</span>(<span class="hljs-number">0</span>).required()<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 定义验证注册和登录表单数据的规则对象</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">reg_login_schema</span> = &#123;<br>  <span class="hljs-attr">body</span>:&#123;<br>    username,<br>    password,<br>    repassword<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 在路由中通过expressJoi(userSchema)的方式，调用中间件进行参数验证</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/adduser/:id&#x27;</span>,<span class="hljs-title function_">expressJoi</span>(userSchema),<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>) &#123;<br>  <span class="hljs-keyword">const</span> body = req.<span class="hljs-property">body</span><br>  res.<span class="hljs-title function_">send</span>(body)<br>&#125;)<br><span class="hljs-comment">// 错误级别中间件</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>,(err,req,res,next) &#123;<br>  <span class="hljs-comment">// 参数校验失败</span><br>  <span class="hljs-keyword">if</span>(err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Joi</span>.<span class="hljs-property">ValidationError</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(&#123;<br>      <span class="hljs-attr">status</span>:<span class="hljs-number">1</span>,<br>      <span class="hljs-attr">message</span>:err.<span class="hljs-property">message</span><br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// 未知错误</span><br>  res.<span class="hljs-title function_">send</span>(&#123;<br>    <span class="hljs-attr">status</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">message</span>:err.<span class="hljs-property">message</span><br>  &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 上述代码和1优化合起来</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">function</span>,(err,req,res,next) &#123;<br>  <span class="hljs-comment">// 参数校验失败</span><br>  <span class="hljs-keyword">if</span>(err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Joi</span>.<span class="hljs-property">ValidationError</span>) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">cc</span>(err)<br>  <span class="hljs-comment">// 未知错误</span><br>  res.<span class="hljs-title function_">cc</span>(err)<br>&#125;)<br><span class="hljs-comment">// app.listen</span><br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在/router/user.js</span><br><span class="hljs-comment">// 导入验证数据的中间件</span><br><span class="hljs-keyword">const</span> expressJoi = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@secook/express-joi&#x27;</span>)<br><span class="hljs-comment">// 导入需要验证的规则对象</span><br><span class="hljs-keyword">const</span> &#123;reg_login_schema&#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../schema/user&#x27;</span>)<br><span class="hljs-comment">// 注册新用户</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/register&#x27;</span>,<span class="hljs-title function_">expressJoi</span>(reg_login_schema),user_handler.<span class="hljs-property">regUser</span>)<br><span class="hljs-comment">// 登录</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/login&#x27;</span>,user_handler.<span class="hljs-property">login</span>)<br></code></pre></td></tr></table></figure>

<h2 id="登录中判断用户输入的密码是否正确"><a href="#登录中判断用户输入的密码是否正确" class="headerlink" title="登录中判断用户输入的密码是否正确"></a>登录中判断用户输入的密码是否正确</h2><p>调用bcrypt.compareSync(用户提交的密码,数据库中的密码) 方法比较密码是否一致<br>返回值布尔值，true一致，false不一致</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> compareResult = bcrypt.<span class="hljs-title function_">compareSync</span>(userInfo.<span class="hljs-property">password</span>,reesults[<span class="hljs-number">0</span>].<span class="hljs-property">password</span>)<br><span class="hljs-comment">// 如果对比的结果等于false,则证明用户输入的密码错误</span><br><span class="hljs-keyword">if</span>(!compareResult) &#123;<br>  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">cc</span>(<span class="hljs-string">&#x27;登录失败&#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 登录成功，生成Token字符串</span><br><span class="hljs-comment">// 通过es6高级语法，快速剔除密码和头像的值，生成token字符串一定要要剔除</span><br><span class="hljs-keyword">const</span> user = &#123;...results[<span class="hljs-number">0</span>],<span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-attr">user_pic</span>:<span class="hljs-string">&#x27;&#x27;</span>&#125; <span class="hljs-comment">// 剔除完毕后，user只保留了用户的id，username，nickname，email这四个属性</span><br><span class="hljs-comment">// 在/router_handler/user.js中导入</span><br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<br><span class="hljs-comment">// 创建config.js文件，向外共享加密和还原token的jwtSecretKey字符串</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">jwtSecretKey</span>:<span class="hljs-string">&#x27;ithema No1&#x27;</span><br>&#125;<br><span class="hljs-comment">// 将用户信息对象加密成token字符串</span><br><span class="hljs-keyword">const</span> config = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../config&#x27;</span>)<br><span class="hljs-comment">// 生成token</span><br><span class="hljs-keyword">const</span> tokenStr = jwt.<span class="hljs-title function_">sign</span>(user,config.<span class="hljs-property">jwtSecretKey</span>,&#123;<br>  <span class="hljs-attr">expiresIn</span>:<span class="hljs-string">&#x27;10h&#x27;</span> <span class="hljs-comment">// token有效期为10h</span><br>&#125;)<br><span class="hljs-comment">// 将生成的token响应给客户端</span><br>res.<span class="hljs-title function_">send</span>(&#123;<br>  <span class="hljs-attr">status</span>:<span class="hljs-number">0</span>,<br>  <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;登录成功&#x27;</span>,<br>  <span class="hljs-attr">token</span>:<span class="hljs-string">&#x27;Bearer&#x27;</span> + tokenStr <span class="hljs-comment">// 为了方便客户端使用token，服务器端直接拼接上Bearer的前缀</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h2 id="重置组件"><a href="#重置组件" class="headerlink" title="重置组件"></a>重置组件</h2><p>定义路由和处理函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// router/userInfo.js,模块中新增重置密码的路由</span><br>router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/updatepwd&#x27;</span>,userInfo_handler.<span class="hljs-property">updatePassword</span>)<br><span class="hljs-comment">// 在router_handler/userInfo.js 模块中，定义并向外共享重置密码的路由处理函数</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">updatePassword</span> = <span class="hljs-function">(<span class="hljs-params">req,res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 验证表单数据</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现思路：旧密码与新密码必须符合密码的验证规则，并且新密码与旧密码一致</span><br><span class="hljs-comment"> * 在schema/user.js模块中使用exports向外共享如下的验证规则</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">exports</span>.<span class="hljs-property">update_password_schema</span> = &#123;<br>  <span class="hljs-attr">body</span>:&#123;<br>    <span class="hljs-comment">// 使用password这个规则，验证req.body.oldPwd的值</span><br>    <span class="hljs-attr">oldPwd</span>:password,<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用joi</span><br><span class="hljs-comment">     * joi.ref(&#x27;oldPwd&#x27;) 表示newPwd的值必须和oldPwd值保持一致</span><br><span class="hljs-comment">     * joi.not表示newPwd的值不能等于oldPwd值</span><br><span class="hljs-comment">     * concat 用于合并joi.not(joi.ref(&#x27;oldPwd&#x27;))和password这两条验证规则</span><br><span class="hljs-comment">     */</span> <br>    <span class="hljs-attr">newPwd</span>:joi.<span class="hljs-title function_">not</span>(joi.<span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;oldPwd&#x27;</span>)).<span class="hljs-title function_">concat</span>(password)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 之后用bcrypt判断实现重置密码功能</span><br><span class="hljs-keyword">const</span> sql = select * <span class="hljs-keyword">from</span> ev_users where id=? <span class="hljs-comment">//定义根据id查询用户数据的SQL语句</span><br><span class="hljs-comment">// 执行SQL语句查询用户是否存在</span><br>db.<span class="hljs-title function_">query</span>(sql,req.<span class="hljs-property">user</span>.<span class="hljs-property">id</span>,<span class="hljs-function">(<span class="hljs-params">err,results</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 执行sql语句失败</span><br>  <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">cc</span>(err)<br>  <span class="hljs-comment">// 检查指定的id用户是否存在</span><br>  <span class="hljs-keyword">if</span>(results.<span class="hljs-property">length</span> !==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">cc</span>(<span class="hljs-string">&#x27;用户不存在&#x27;</span>)<br>  res.<span class="hljs-title function_">cc</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;)<br><br><span class="hljs-keyword">const</span> bcrypt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;bcryptjs&#x27;</span>)<br><span class="hljs-keyword">const</span> compareResult = bcrypt.<span class="hljs-title function_">compareSync</span>(req.<span class="hljs-property">body</span>.<span class="hljs-property">oldPwd</span>,results[<span class="hljs-number">0</span>].<span class="hljs-property">password</span>)<br><span class="hljs-keyword">if</span>(!compareResult) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">cc</span>(<span class="hljs-string">&#x27;密码错误&#x27;</span>)<br><br><span class="hljs-comment">// 再之后对新密码进行bcrypt加密后，更新到数据库中</span><br><span class="hljs-keyword">const</span> sqll = <span class="hljs-string">&#x27;update ev_users set password=? where id=?&#x27;</span><br><span class="hljs-comment">// 对新密码进行bcrypt加密处理</span><br><span class="hljs-keyword">const</span> newPwd = bcrypt.<span class="hljs-title function_">hashSync</span>(req.<span class="hljs-property">body</span>.<span class="hljs-property">newPwd</span>,<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 执行sql语句，根据id更新用户的密码</span><br>db.<span class="hljs-title function_">query</span>(sql,[newPwd,req.<span class="hljs-property">user</span>.<span class="hljs-property">id</span>],<span class="hljs-function">(<span class="hljs-params">err,results</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">cc</span>(err)<br>  <span class="hljs-keyword">if</span>(results.<span class="hljs-property">affectedRows</span> !== <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">cc</span>(<span class="hljs-string">&#x27;更新密码失败&#x27;</span>)<br>  <span class="hljs-comment">// 更新密码成功</span><br>  res.<span class="hljs-title function_">cc</span>(<span class="hljs-string">&#x27;更新密码成功!&#x27;</span>,<span class="hljs-number">0</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><div id="paginator"></div></div><div id="post-footer"></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">John Doe</a></h1><div id="description"><p>支持大家讨论交流</p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#node%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">node实现登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88JavaScript%E5%8F%AF%E4%BB%A5%E6%93%8D%E4%BD%9CDOM%E5%92%8CBOM%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">为什么JavaScript可以操作DOM和BOM？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFnodejs"><span class="toc-number">3.</span> <span class="toc-text">什么是nodejs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nodejs%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">4.</span> <span class="toc-text">nodejs环境的安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97"><span class="toc-number">5.</span> <span class="toc-text">fs文件系统模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fs%E7%9A%84%E8%B7%AF%E5%BE%84%E6%8B%BC%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">fs的路径拼接问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E6%A8%A1%E5%9D%97"><span class="toc-number">6.</span> <span class="toc-text">http模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">7.</span> <span class="toc-text">服务器相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">创建最基本的web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#req%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1%E3%80%81-%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1"><span class="toc-number">8.1.</span> <span class="toc-text">req请求对象、 响应对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.</span> <span class="toc-text">解决中文乱码问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%8D%E5%90%8C%E7%9A%84url%E5%93%8D%E5%BA%94%E4%B8%8D%E5%90%8C%E7%9A%84html%E5%86%85%E5%AE%B9"><span class="toc-number">9.</span> <span class="toc-text">根据不同的url响应不同的html内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E6%A1%88%E4%BE%8Bserver%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">时钟案例server中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83"><span class="toc-number">10.1.</span> <span class="toc-text">模块化规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nodejs%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">10.2.</span> <span class="toc-text">nodejs中的模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#module%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.3.</span> <span class="toc-text">module对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#module-exports-%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.3.1.</span> <span class="toc-text">module.exports 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E5%A4%96%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">10.3.2.</span> <span class="toc-text">向外共享模块作用域中的成员</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exports-%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.</span> <span class="toc-text">exports 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node-js%E9%81%B5%E5%BE%AACommonJS%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83"><span class="toc-number">12.</span> <span class="toc-text">node.js遵循CommonJS模块化规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E5%8C%85%E7%9A%84%E9%95%9C%E5%83%8F%E6%BA%90"><span class="toc-number">13.</span> <span class="toc-text">下包的镜像源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%B8%8B%E5%8C%85%E9%80%9F%E5%BA%A6%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">14.</span> <span class="toc-text">解决下包速度慢的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#md%E8%BD%AChtml"><span class="toc-number">15.</span> <span class="toc-text">md转html</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8C%85"><span class="toc-number">16.</span> <span class="toc-text">开发属于自己的包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">17.</span> <span class="toc-text">模块的加载机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">18.</span> <span class="toc-text">web开发模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">18.1.</span> <span class="toc-text">如何选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="toc-number">19.</span> <span class="toc-text">session认证机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie"><span class="toc-number">19.1.</span> <span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">19.2.</span> <span class="toc-text">session工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81"><span class="toc-number">20.</span> <span class="toc-text">前后端的身份认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#express%E4%BD%BF%E7%94%A8session"><span class="toc-number">20.1.</span> <span class="toc-text">express使用session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jwt%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="toc-number">20.2.</span> <span class="toc-text">jwt认证机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AF%B9%E5%AF%86%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86%E5%A4%84%E7%90%86"><span class="toc-number">21.</span> <span class="toc-text">项目中对密码进行加密处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%96%B0%E7%94%A8%E6%88%B7"><span class="toc-number">22.</span> <span class="toc-text">插入新用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-number">23.</span> <span class="toc-text">优化代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E4%B8%AD%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E5%AF%86%E7%A0%81%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE"><span class="toc-number">24.</span> <span class="toc-text">登录中判断用户输入的密码是否正确</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE%E7%BB%84%E4%BB%B6"><span class="toc-number">25.</span> <span class="toc-text">重置组件</span></a></li></ol></div><section id="total"><a id="total-archives" href="/archives"><span class="total-title">文章 总数:</span><span class="total-number">5</span></a><div id="total-tags"><span class="total-title">标签:</span><span class="total-number">1</span></div><div id="total-categories"><span class="total-title">分类:</span><span class="total-number">5</span></div></section></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {code.findCode();
document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>